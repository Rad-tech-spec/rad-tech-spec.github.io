import { fork } from 'node:child_process';
import process from 'node:process';
import { d as defineCommand, e as extendsArgs, f as envNameArgs, b as legacyRootDirArgs, a as dotEnvArgs, l as logLevelArgs, c as cwdArgs } from '../shared/nuxi.GLC40kEn.mjs';
import { i as isSocketSupported, l as listen } from '../shared/nuxi.8mhVoXwa.mjs';
import ft from 'node:http';
import https from 'node:https';
import { EventEmitter } from 'node:events';
import { g as getArgs, p as parseArgs } from '../shared/nuxi.DUZ_WukQ.mjs';
import { s as semverExports } from '../shared/nuxi.DU9QXUOf.mjs';
import { b as a, d as c, l as logger, D } from '../shared/nuxi.DQjfoGl0.mjs';
import { i as initialize, r as resolveLoadingTemplate, a as renderError, b as isSocketURL, p as parseSocketURL } from './index2.mjs';
import { s as showVersions } from '../shared/nuxi.BXGZ9qFF.mjs';
import { o as overrideEnv } from '../shared/nuxi.C_u-rG9b.mjs';
import { l as loadKit } from '../shared/nuxi.BiWTNJI4.mjs';
import { r as resolve } from '../shared/nuxi.Do0aYBCO.mjs';
import 'node:crypto';
import 'node:path';
import 'node:tty';
import 'node:url';
import 'node:util';
import 'node:net';
import 'node:os';
import 'node:fs/promises';
import '../shared/nuxi.BAGoDD49.mjs';
import 'http';
import 'https';
import '../shared/nuxi.D2_bzAv0.mjs';
import 'node:fs';
import 'crypto';
import '../shared/nuxi.4t9faemh.mjs';
import '../shared/nuxi.BLb4POFS.mjs';
import 'node:assert';
import 'node:v8';
import '../shared/nuxi.CTyTlDmo.mjs';
import '../shared/nuxi.QWnQy_ku.mjs';
import '../shared/nuxi.CrvQqJcE.mjs';
import '../shared/nuxi.DQbQuzNE.mjs';
import 'fs/promises';
import 'util';
import 'path';
import 'url';

const upgradeHeader = /(^|,)\s*upgrade\s*($|,)/i;
const isSSL = /^https|wss/;
function setupOutgoing(outgoing, options, req, forward) {
  outgoing.port = options[forward || "target"].port || (isSSL.test(options[forward || "target"].protocol) ? 443 : 80);
  for (const e of [
    "host",
    "hostname",
    "socketPath",
    "pfx",
    "key",
    "passphrase",
    "cert",
    "ca",
    "ciphers",
    "secureProtocol"
  ]) {
    outgoing[e] = options[forward || "target"][e];
  }
  outgoing.method = options.method || req.method;
  outgoing.headers = { ...req.headers };
  if (options.headers) {
    outgoing.headers = { ...outgoing.headers, ...options.headers };
  }
  if (options.auth) {
    outgoing.auth = options.auth;
  }
  if (options.ca) {
    outgoing.ca = options.ca;
  }
  if (isSSL.test(options[forward || "target"].protocol)) {
    outgoing.rejectUnauthorized = options.secure === undefined ? true : options.secure;
  }
  outgoing.agent = options.agent || false;
  outgoing.localAddress = options.localAddress;
  if (!outgoing.agent) {
    outgoing.headers = outgoing.headers || {};
    if (typeof outgoing.headers.connection !== "string" || !upgradeHeader.test(outgoing.headers.connection)) {
      outgoing.headers.connection = "close";
    }
  }
  const target = options[forward || "target"];
  const targetPath = target && options.prependPath !== false ? target.pathname || target.path || "" : "";
  const parsed = new URL(req.url, "http://localhost");
  let outgoingPath = options.toProxy ? req.url : parsed.pathname + parsed.search || "";
  outgoingPath = options.ignorePath ? "" : outgoingPath;
  outgoing.path = joinURL(targetPath, outgoingPath);
  if (options.changeOrigin) {
    outgoing.headers.host = requiresPort(outgoing.port, options[forward || "target"].protocol) && !hasPort(outgoing.host) ? outgoing.host + ":" + outgoing.port : outgoing.host;
  }
  return outgoing;
}
function joinURL(base, path) {
  if (!base || base === "/") {
    return path || "/";
  }
  if (!path || path === "/") {
    return base || "/";
  }
  const baseHasTrailing = base[base.length - 1] === "/";
  const pathHasLeading = path[0] === "/";
  if (baseHasTrailing && pathHasLeading) {
    return base + path.slice(1);
  }
  if (!baseHasTrailing && !pathHasLeading) {
    return base + "/" + path;
  }
  return base + path;
}
function setupSocket(socket) {
  socket.setTimeout(0);
  socket.setNoDelay(true);
  socket.setKeepAlive(true, 0);
  return socket;
}
function getPort(req) {
  const res = req.headers.host ? req.headers.host.match(/:(\d+)/) : "";
  if (res) {
    return res[1];
  }
  return hasEncryptedConnection(req) ? "443" : "80";
}
function hasEncryptedConnection(req) {
  return Boolean(req.connection.encrypted || req.connection.pair);
}
function rewriteCookieProperty(header, config, property) {
  if (Array.isArray(header)) {
    return header.map(function(headerElement) {
      return rewriteCookieProperty(headerElement, config, property);
    });
  }
  return header.replace(
    new RegExp(String.raw`(;\s*` + property + "=)([^;]+)", "i"),
    function(match, prefix, previousValue) {
      let newValue;
      if (previousValue in config) {
        newValue = config[previousValue];
      } else if ("*" in config) {
        newValue = config["*"];
      } else {
        return match;
      }
      return newValue ? prefix + newValue : "";
    }
  );
}
function hasPort(host) {
  return !!~host.indexOf(":");
}
function requiresPort(_port, _protocol) {
  const protocol = _protocol.split(":")[0];
  const port = +_port;
  if (!port) return false;
  switch (protocol) {
    case "http":
    case "ws": {
      return port !== 80;
    }
    case "https":
    case "wss": {
      return port !== 443;
    }
    case "ftp": {
      return port !== 21;
    }
    case "gopher": {
      return port !== 70;
    }
    case "file": {
      return false;
    }
  }
  return port !== 0;
}

function defineProxyMiddleware(m) {
  return m;
}
function defineProxyOutgoingMiddleware(m) {
  return m;
}

const redirectRegex = /^201|30([1278])$/;
const removeChunked = defineProxyOutgoingMiddleware((req, res, proxyRes) => {
  if (req.httpVersion === "1.0") {
    delete proxyRes.headers["transfer-encoding"];
  }
});
const setConnection = defineProxyOutgoingMiddleware((req, res, proxyRes) => {
  if (req.httpVersion === "1.0") {
    proxyRes.headers.connection = req.headers.connection || "close";
  } else if (req.httpVersion !== "2.0" && !proxyRes.headers.connection) {
    proxyRes.headers.connection = req.headers.connection || "keep-alive";
  }
});
const setRedirectHostRewrite = defineProxyOutgoingMiddleware(
  (req, res, proxyRes, options) => {
    if ((options.hostRewrite || options.autoRewrite || options.protocolRewrite) && proxyRes.headers.location && redirectRegex.test(String(proxyRes.statusCode))) {
      const target = new URL(options.target);
      const u = new URL(proxyRes.headers.location);
      if (target.host !== u.host) {
        return;
      }
      if (options.hostRewrite) {
        u.host = options.hostRewrite;
      } else if (options.autoRewrite) {
        u.host = req.headers.host;
      }
      if (options.protocolRewrite) {
        u.protocol = options.protocolRewrite;
      }
      proxyRes.headers.location = u.toString();
    }
  }
);
const writeHeaders = defineProxyOutgoingMiddleware(
  (req, res, proxyRes, options) => {
    let rewriteCookieDomainConfig = options.cookieDomainRewrite;
    let rewriteCookiePathConfig = options.cookiePathRewrite;
    const preserveHeaderKeyCase = options.preserveHeaderKeyCase;
    let rawHeaderKeyMap;
    const setHeader = function(key, header) {
      if (header === undefined) {
        return;
      }
      if (rewriteCookieDomainConfig && key.toLowerCase() === "set-cookie") {
        header = rewriteCookieProperty(
          header,
          rewriteCookieDomainConfig,
          "domain"
        );
      }
      if (rewriteCookiePathConfig && key.toLowerCase() === "set-cookie") {
        header = rewriteCookieProperty(header, rewriteCookiePathConfig, "path");
      }
      res.setHeader(String(key).trim(), header);
    };
    if (typeof rewriteCookieDomainConfig === "string") {
      rewriteCookieDomainConfig = { "*": rewriteCookieDomainConfig };
    }
    if (typeof rewriteCookiePathConfig === "string") {
      rewriteCookiePathConfig = { "*": rewriteCookiePathConfig };
    }
    if (preserveHeaderKeyCase && proxyRes.rawHeaders !== undefined) {
      rawHeaderKeyMap = {};
      for (let i = 0; i < proxyRes.rawHeaders.length; i += 2) {
        const key = proxyRes.rawHeaders[i];
        rawHeaderKeyMap[key.toLowerCase()] = key;
      }
    }
    for (let key of Object.keys(proxyRes.headers)) {
      const header = proxyRes.headers[key];
      if (preserveHeaderKeyCase && rawHeaderKeyMap) {
        key = rawHeaderKeyMap[key] || key;
      }
      setHeader(key, header);
    }
  }
);
const writeStatusCode = defineProxyOutgoingMiddleware((req, res, proxyRes) => {
  if (proxyRes.statusMessage) {
    res.statusCode = proxyRes.statusCode;
    res.statusMessage = proxyRes.statusMessage;
  } else {
    res.statusCode = proxyRes.statusCode;
  }
});
const webOutgoingMiddleware = [
  removeChunked,
  setConnection,
  setRedirectHostRewrite,
  writeHeaders,
  writeStatusCode
];

const nativeAgents = { http: ft, https: https };
const deleteLength = defineProxyMiddleware((req) => {
  if ((req.method === "DELETE" || req.method === "OPTIONS") && !req.headers["content-length"]) {
    req.headers["content-length"] = "0";
    delete req.headers["transfer-encoding"];
  }
});
const timeout = defineProxyMiddleware((req, res, options) => {
  if (options.timeout) {
    req.socket.setTimeout(options.timeout);
  }
});
const XHeaders$1 = defineProxyMiddleware((req, res, options) => {
  if (!options.xfwd) {
    return;
  }
  const encrypted = req.isSpdy || hasEncryptedConnection(req);
  const values = {
    for: req.connection.remoteAddress || req.socket.remoteAddress,
    port: getPort(req),
    proto: encrypted ? "https" : "http"
  };
  for (const header of ["for", "port", "proto"]) {
    req.headers["x-forwarded-" + header] = (req.headers["x-forwarded-" + header] || "") + (req.headers["x-forwarded-" + header] ? "," : "") + values[header];
  }
  req.headers["x-forwarded-host"] = req.headers["x-forwarded-host"] || req.headers.host || "";
});
const stream$1 = defineProxyMiddleware(
  (req, res, options, server, head, callback) => {
    server.emit("start", req, res, options.target || options.forward);
    const agents = nativeAgents;
    const http = agents.http;
    const https = agents.https;
    if (options.forward) {
      const forwardReq = (options.forward.protocol === "https:" ? https : http).request(setupOutgoing(options.ssl || {}, options, req, "forward"));
      const forwardError = createErrorHandler(forwardReq, options.forward);
      req.on("error", forwardError);
      forwardReq.on("error", forwardError);
      (options.buffer || req).pipe(forwardReq);
      if (!options.target) {
        res.end();
        return;
      }
    }
    const proxyReq = (options.target.protocol === "https:" ? https : http).request(setupOutgoing(options.ssl || {}, options, req));
    proxyReq.on("socket", (socket) => {
      if (server && !proxyReq.getHeader("expect")) {
        server.emit("proxyReq", proxyReq, req, res, options);
      }
    });
    if (options.proxyTimeout) {
      proxyReq.setTimeout(options.proxyTimeout, function() {
        proxyReq.abort();
      });
    }
    req.on("aborted", function() {
      proxyReq.abort();
    });
    const proxyError = createErrorHandler(proxyReq, options.target);
    req.on("error", proxyError);
    proxyReq.on("error", proxyError);
    function createErrorHandler(proxyReq2, url) {
      return function proxyError2(err) {
        if (req.socket.destroyed && err.code === "ECONNRESET") {
          server.emit("econnreset", err, req, res, url);
          return proxyReq2.abort();
        }
        if (callback) {
          callback(err, req, res, url);
        } else {
          server.emit("error", err, req, res, url);
        }
      };
    }
    (options.buffer || req).pipe(proxyReq);
    proxyReq.on("response", function(proxyRes) {
      if (server) {
        server.emit("proxyRes", proxyRes, req, res);
      }
      if (!res.headersSent && !options.selfHandleResponse) {
        for (const pass of webOutgoingMiddleware) {
          if (pass(req, res, proxyRes, options)) {
            break;
          }
        }
      }
      if (res.finished) {
        if (server) {
          server.emit("end", req, res, proxyRes);
        }
      } else {
        res.on("close", function() {
          proxyRes.destroy();
        });
        proxyRes.on("end", function() {
          if (server) {
            server.emit("end", req, res, proxyRes);
          }
        });
        if (!options.selfHandleResponse) {
          proxyRes.pipe(res);
        }
      }
    });
  }
);
const webIncomingMiddleware = [
  deleteLength,
  timeout,
  XHeaders$1,
  stream$1
];

const checkMethodAndHeader = defineProxyMiddleware((req, socket) => {
  if (req.method !== "GET" || !req.headers.upgrade) {
    socket.destroy();
    return true;
  }
  if (req.headers.upgrade.toLowerCase() !== "websocket") {
    socket.destroy();
    return true;
  }
});
const XHeaders = defineProxyMiddleware((req, socket, options) => {
  if (!options.xfwd) {
    return;
  }
  const values = {
    for: req.connection.remoteAddress || req.socket.remoteAddress,
    port: getPort(req),
    proto: hasEncryptedConnection(req) ? "wss" : "ws"
  };
  for (const header of ["for", "port", "proto"]) {
    req.headers["x-forwarded-" + header] = (req.headers["x-forwarded-" + header] || "") + (req.headers["x-forwarded-" + header] ? "," : "") + values[header];
  }
});
const stream = defineProxyMiddleware(
  (req, socket, options, server, head, callback) => {
    const createHttpHeader = function(line, headers) {
      return Object.keys(headers).reduce(
        function(head2, key) {
          const value = headers[key];
          if (!Array.isArray(value)) {
            head2.push(key + ": " + value);
            return head2;
          }
          for (const element of value) {
            head2.push(key + ": " + element);
          }
          return head2;
        },
        [line]
      ).join("\r\n") + "\r\n\r\n";
    };
    setupSocket(socket);
    if (head && head.length > 0) {
      socket.unshift(head);
    }
    const proxyReq = (isSSL.test(options.target.protocol) ? https : ft).request(setupOutgoing(options.ssl || {}, options, req));
    if (server) {
      server.emit("proxyReqWs", proxyReq, req, socket, options, head);
    }
    proxyReq.on("error", onOutgoingError);
    proxyReq.on("response", function(res) {
      if (!res.upgrade) {
        socket.write(
          createHttpHeader(
            "HTTP/" + res.httpVersion + " " + res.statusCode + " " + res.statusMessage,
            res.headers
          )
        );
        res.pipe(socket);
      }
    });
    proxyReq.on("upgrade", function(proxyRes, proxySocket, proxyHead) {
      proxySocket.on("error", onOutgoingError);
      proxySocket.on("end", function() {
        server.emit("close", proxyRes, proxySocket, proxyHead);
      });
      socket.on("error", function() {
        proxySocket.end();
      });
      setupSocket(proxySocket);
      if (proxyHead && proxyHead.length > 0) {
        proxySocket.unshift(proxyHead);
      }
      socket.write(
        createHttpHeader("HTTP/1.1 101 Switching Protocols", proxyRes.headers)
      );
      proxySocket.pipe(socket).pipe(proxySocket);
      server.emit("open", proxySocket);
      server.emit("proxySocket", proxySocket);
    });
    proxyReq.end();
    function onOutgoingError(err) {
      if (callback) {
        callback(err, req, socket);
      } else {
        server.emit("error", err, req, socket);
      }
      socket.end();
    }
  }
);
const websocketIncomingMiddleware = [
  checkMethodAndHeader,
  XHeaders,
  stream
];

class ProxyServer extends EventEmitter {
  _server;
  _webPasses = [...webIncomingMiddleware];
  _wsPasses = [...websocketIncomingMiddleware];
  options;
  web;
  ws;
  /**
   * Creates the proxy server with specified options.
   * @param options - Config object passed to the proxy
   */
  constructor(options = {}) {
    super();
    this.options = options || {};
    this.options.prependPath = options.prependPath !== false;
    this.web = _createProxyFn("web", this);
    this.ws = _createProxyFn("ws", this);
  }
  /**
   * A function that wraps the object in a webserver, for your convenience
   * @param port - Port to listen on
   * @param hostname - The hostname to listen on
   */
  listen(port, hostname) {
    const closure = (req, res) => {
      this.web(req, res);
    };
    this._server = this.options.ssl ? https.createServer(this.options.ssl, closure) : ft.createServer(closure);
    if (this.options.ws) {
      this._server.on("upgrade", (req, socket, head) => {
        this._ws(req, socket, head);
      });
    }
    this._server.listen(port, hostname);
    return this;
  }
  /**
   * A function that closes the inner webserver and stops listening on given port
   */
  close(callback) {
    if (this._server) {
      this._server.close((...args) => {
        this._server = undefined;
        if (callback) {
          Reflect.apply(callback, undefined, args);
        }
      });
    }
  }
  before(type, passName, pass) {
    if (type !== "ws" && type !== "web") {
      throw new Error("type must be `web` or `ws`");
    }
    const passes = type === "ws" ? this._wsPasses : this._webPasses;
    let i = false;
    for (const [idx, v] of passes.entries()) {
      if (v.name === passName) {
        i = idx;
      }
    }
    if (i === false) {
      throw new Error("No such pass");
    }
    passes.splice(i, 0, pass);
  }
  after(type, passName, pass) {
    if (type !== "ws" && type !== "web") {
      throw new Error("type must be `web` or `ws`");
    }
    const passes = type === "ws" ? this._wsPasses : this._webPasses;
    let i = false;
    for (const [idx, v] of passes.entries()) {
      if (v.name === passName) {
        i = idx;
      }
    }
    if (i === false) {
      throw new Error("No such pass");
    }
    passes.splice(i++, 0, pass);
  }
}
function createProxyServer(options = {}) {
  return new ProxyServer(options);
}
function _createProxyFn(type, server) {
  return function(req, res, opts, head) {
    const requestOptions = { ...opts, ...server.options };
    for (const key of ["target", "forward"]) {
      if (typeof requestOptions[key] === "string") {
        requestOptions[key] = new URL(requestOptions[key]);
      }
    }
    if (!requestOptions.target && !requestOptions.forward) {
      return this.emit(
        "error",
        new Error("Must provide a proper URL as target")
      );
    }
    let _resolve;
    let _reject;
    const callbackPromise = new Promise((resolve, reject) => {
      _resolve = resolve;
      _reject = reject;
    });
    res.on("close", () => {
      _resolve();
    });
    res.on("error", (error) => {
      _reject(error);
    });
    for (const pass of type === "ws" ? server._wsPasses : server._webPasses) {
      const stop = pass(
        req,
        res,
        requestOptions,
        server,
        head,
        (error) => {
          _reject(error);
        }
      );
      if (stop) {
        _resolve();
        break;
      }
    }
    return callbackPromise;
  };
}

const startTime = Date.now();
const forkSupported = !a && (!c || isBunForkSupported());
const listhenArgs = getArgs();
const command = defineCommand({
  meta: {
    name: "dev",
    description: "Run Nuxt development server"
  },
  args: {
    ...cwdArgs,
    ...logLevelArgs,
    ...dotEnvArgs,
    ...legacyRootDirArgs,
    ...envNameArgs,
    ...extendsArgs,
    clear: {
      type: "boolean",
      description: "Clear console on restart",
      negativeDescription: "Disable clear console on restart"
    },
    fork: {
      type: "boolean",
      description: forkSupported ? "Disable forked mode" : "Enable forked mode",
      negativeDescription: "Disable forked mode",
      default: forkSupported,
      alias: ["f"]
    },
    ...{
      ...listhenArgs,
      "port": {
        ...listhenArgs.port,
        description: "Port to listen on (default: `NUXT_PORT || NITRO_PORT || PORT || nuxtOptions.devServer.port`)",
        alias: ["p"]
      },
      "open": {
        ...listhenArgs.open,
        alias: ["o"],
        default: false
      },
      "host": {
        ...listhenArgs.host,
        alias: ["h"],
        description: "Host to listen on (default: `NUXT_HOST || NITRO_HOST || HOST || nuxtOptions.devServer?.host`)"
      },
      "clipboard": { ...listhenArgs.clipboard, default: false },
      "https.domains": {
        ...listhenArgs["https.domains"],
        description: "Comma separated list of domains and IPs, the autogenerated certificate should be valid for (https: true)"
      }
    },
    sslCert: {
      type: "string",
      description: "(DEPRECATED) Use `--https.cert` instead."
    },
    sslKey: {
      type: "string",
      description: "(DEPRECATED) Use `--https.key` instead."
    }
  },
  async run(ctx) {
    overrideEnv("development");
    const cwd = resolve(ctx.args.cwd || ctx.args.rootDir);
    showVersions(cwd);
    const { loadNuxtConfig } = await loadKit(cwd);
    const nuxtOptions = await loadNuxtConfig({
      cwd,
      dotenv: { cwd, fileName: ctx.args.dotenv },
      envName: ctx.args.envName,
      // c12 will fall back to NODE_ENV
      overrides: {
        dev: true,
        logLevel: ctx.args.logLevel,
        ...ctx.args.extends && { extends: ctx.args.extends },
        ...ctx.data?.overrides
      }
    });
    const listenOptions = resolveListenOptions(nuxtOptions, ctx.args);
    if (!ctx.args.fork) {
      const { listener, close: close2 } = await initialize({
        cwd,
        args: ctx.args,
        hostname: listenOptions.hostname,
        public: listenOptions.public,
        publicURLs: void 0,
        proxy: {
          https: listenOptions.https
        }
      }, { data: ctx.data }, listenOptions);
      return {
        listener,
        async close() {
          await close2();
          await listener.close();
        }
      };
    }
    const devProxy = await createDevProxy(cwd, nuxtOptions, listenOptions);
    const nuxtSocketEnv = process.env.NUXT_SOCKET ? process.env.NUXT_SOCKET === "1" : void 0;
    const useSocket = nuxtSocketEnv ?? (nuxtOptions._majorVersion === 4 && await isSocketSupported());
    const urls = await devProxy.listener.getURLs();
    const { onRestart, onReady, close } = await initialize({
      cwd,
      args: ctx.args,
      hostname: listenOptions.hostname,
      public: listenOptions.public,
      publicURLs: urls.map((r) => r.url),
      proxy: {
        url: devProxy.listener.url,
        urls,
        https: devProxy.listener.https,
        addr: devProxy.listener.address
      }
      // if running with nuxt v4 or `NUXT_SOCKET=1`, we use the socket listener
      // otherwise pass 'true' to listen on a random port instead
    }, {}, useSocket ? void 0 : true);
    onReady((address) => devProxy.setAddress(address));
    const fork2 = startSubprocess(cwd, ctx.args, ctx.rawArgs, listenOptions);
    onRestart(async (devServer) => {
      const [subprocess] = await Promise.all([
        fork2,
        devServer.close().catch(() => {
        })
      ]);
      await subprocess.initialize(devProxy, useSocket);
    });
    return {
      listener: devProxy.listener,
      async close() {
        await close();
        const subprocess = await fork2;
        subprocess.kill(0);
        await devProxy.listener.close();
      }
    };
  }
});
async function createDevProxy(cwd, nuxtOptions, listenOptions) {
  let loadingMessage = "Nuxt dev server is starting...";
  let error;
  let address;
  let loadingTemplate = nuxtOptions.devServer.loadingTemplate;
  const proxy = createProxyServer({});
  proxy.on("proxyReq", (proxyReq, req) => {
    if (!proxyReq.hasHeader("x-forwarded-for")) {
      const address2 = req.socket.remoteAddress;
      if (address2) {
        proxyReq.appendHeader("x-forwarded-for", address2);
      }
    }
    if (!proxyReq.hasHeader("x-forwarded-port")) {
      const localPort = req?.socket?.localPort;
      if (localPort) {
        proxyReq.setHeader("x-forwarded-port", req.socket.localPort);
      }
    }
    if (!proxyReq.hasHeader("x-forwarded-Proto")) {
      const encrypted = req?.connection?.encrypted;
      proxyReq.setHeader("x-forwarded-proto", encrypted ? "https" : "http");
    }
  });
  const listener = await listen((req, res) => {
    if (error) {
      renderError(req, res, error);
      return;
    }
    if (!address) {
      res.statusCode = 503;
      res.setHeader("Content-Type", "text/html");
      res.setHeader("Cache-Control", "no-store");
      if (loadingTemplate) {
        res.end(loadingTemplate({ loading: loadingMessage }));
        return;
      }
      async function resolveLoadingMessage() {
        loadingTemplate = await resolveLoadingTemplate(cwd);
        res.end(loadingTemplate({ loading: loadingMessage }));
      }
      return resolveLoadingMessage();
    }
    const target = isSocketURL(address) ? parseSocketURL(address) : address;
    proxy.web(req, res, { target });
  }, listenOptions);
  listener.server.on("upgrade", (req, socket, head) => {
    if (!address) {
      if (!socket.destroyed) {
        socket.end();
      }
      return;
    }
    const target = isSocketURL(address) ? parseSocketURL(address) : address;
    return proxy.ws(req, socket, { target, xfwd: true }, head).catch(() => {
      if (!socket.destroyed) {
        socket.end();
      }
    });
  });
  return {
    listener,
    setAddress: (_addr) => {
      address = _addr;
    },
    setLoadingMessage: (_msg) => {
      loadingMessage = _msg;
    },
    setError: (_error) => {
      error = _error;
    },
    clearError() {
      error = void 0;
    }
  };
}
async function startSubprocess(cwd, args, rawArgs, listenOptions) {
  let childProc;
  let devProxy;
  let ready;
  const kill = (signal) => {
    if (childProc) {
      childProc.kill(signal === 0 && D ? "SIGTERM" : signal);
      childProc = void 0;
    }
  };
  async function initialize2(proxy, socket) {
    devProxy = proxy;
    const urls = await devProxy.listener.getURLs();
    await ready;
    childProc.send({
      type: "nuxt:internal:dev:context",
      socket,
      context: {
        cwd,
        args,
        hostname: listenOptions.hostname,
        public: listenOptions.public,
        publicURLs: urls.map((r) => r.url),
        proxy: {
          url: devProxy.listener.url,
          urls,
          https: devProxy.listener.https
        }
      }
    });
  }
  async function restart() {
    devProxy?.clearError();
    if (process.platform === "win32") {
      kill("SIGTERM");
    } else {
      kill("SIGHUP");
    }
    childProc = fork(globalThis.__nuxt_cli__.devEntry, rawArgs, {
      execArgv: ["--enable-source-maps", process.argv.find((a) => a.includes("--inspect"))].filter(Boolean),
      env: {
        ...process.env,
        __NUXT__FORK: "true"
      }
    });
    childProc.on("close", (errorCode) => {
      if (errorCode) {
        process.exit(errorCode);
      }
    });
    ready = new Promise((resolve2, reject) => {
      childProc.on("error", reject);
      childProc.on("message", (message) => {
        if (message.type === "nuxt:internal:dev:fork-ready") {
          resolve2();
        } else if (message.type === "nuxt:internal:dev:ready") {
          devProxy.setAddress(message.address);
          if (startTime) {
            logger.debug(`Dev server ready for connections in ${Date.now() - startTime}ms`);
          }
        } else if (message.type === "nuxt:internal:dev:loading") {
          devProxy.setAddress(void 0);
          devProxy.setLoadingMessage(message.message);
          devProxy.clearError();
        } else if (message.type === "nuxt:internal:dev:loading:error") {
          devProxy.setAddress(void 0);
          devProxy.setError(message.error);
        } else if (message.type === "nuxt:internal:dev:restart") {
          restart();
        } else if (message.type === "nuxt:internal:dev:rejection") {
          logger.info(`Restarting Nuxt due to error: \`${message.message}\``);
          restart();
        }
      });
    });
  }
  for (const signal of [
    "exit",
    "SIGTERM",
    "SIGINT",
    "SIGQUIT"
  ]) {
    process.once(signal, () => {
      kill(signal === "exit" ? 0 : signal);
    });
  }
  await restart();
  return {
    initialize: initialize2,
    restart,
    kill
  };
}
function resolveListenOptions(nuxtOptions, args) {
  const _port = args.port ?? args.p ?? process.env.NUXT_PORT ?? process.env.NITRO_PORT ?? process.env.PORT ?? nuxtOptions.devServer.port;
  const _hostname = typeof args.host === "string" ? args.host : args.host === true ? "" : process.env.NUXT_HOST ?? process.env.NITRO_HOST ?? process.env.HOST ?? (nuxtOptions.devServer?.host || void 0) ?? void 0;
  const _public = args.public ?? (_hostname && !["localhost", "127.0.0.1", "::1"].includes(_hostname)) ? true : void 0;
  const _httpsCert = args["https.cert"] || args.sslCert || process.env.NUXT_SSL_CERT || process.env.NITRO_SSL_CERT || typeof nuxtOptions.devServer.https !== "boolean" && nuxtOptions.devServer.https && "cert" in nuxtOptions.devServer.https && nuxtOptions.devServer.https.cert || "";
  const _httpsKey = args["https.key"] || args.sslKey || process.env.NUXT_SSL_KEY || process.env.NITRO_SSL_KEY || typeof nuxtOptions.devServer.https !== "boolean" && nuxtOptions.devServer.https && "key" in nuxtOptions.devServer.https && nuxtOptions.devServer.https.key || "";
  const _httpsPfx = args["https.pfx"] || typeof nuxtOptions.devServer.https !== "boolean" && nuxtOptions.devServer.https && "pfx" in nuxtOptions.devServer.https && nuxtOptions.devServer.https.pfx || "";
  const _httpsPassphrase = args["https.passphrase"] || typeof nuxtOptions.devServer.https !== "boolean" && nuxtOptions.devServer.https && "passphrase" in nuxtOptions.devServer.https && nuxtOptions.devServer.https.passphrase || "";
  const httpsEnabled = !!(args.https ?? nuxtOptions.devServer.https);
  const _listhenOptions = parseArgs({
    ...args,
    "open": args.o || args.open,
    "https": httpsEnabled,
    "https.cert": _httpsCert,
    "https.key": _httpsKey,
    "https.pfx": _httpsPfx,
    "https.passphrase": _httpsPassphrase
  });
  const httpsOptions = httpsEnabled && {
    ...nuxtOptions.devServer.https,
    ..._listhenOptions.https
  };
  return {
    ..._listhenOptions,
    port: _port,
    hostname: _hostname,
    public: _public,
    https: httpsOptions,
    baseURL: nuxtOptions.app.baseURL.startsWith("./") ? nuxtOptions.app.baseURL.slice(1) : nuxtOptions.app.baseURL
  };
}
function isBunForkSupported() {
  const bunVersion = globalThis.Bun.version;
  return semverExports.satisfies(bunVersion, ">=1.2");
}

export { command as default };
