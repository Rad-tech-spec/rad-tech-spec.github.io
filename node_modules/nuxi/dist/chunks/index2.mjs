import process$1 from 'node:process';
import { d as defu } from '../shared/nuxi.D2_bzAv0.mjs';
import { g as getSocketAddress, c as cleanSocket, l as listen } from '../shared/nuxi.8mhVoXwa.mjs';
import { Server } from 'node:http';
import EventEmitter from 'node:events';
import { watch, existsSync } from 'node:fs';
import { mkdir } from 'node:fs/promises';
import { pathToFileURL } from 'node:url';
import { r as resolveModulePath } from '../shared/nuxi.BLb4POFS.mjs';
import { t as toNodeListener } from '../shared/nuxi.CTyTlDmo.mjs';
import { p as p$1 } from '../shared/nuxi.DQjfoGl0.mjs';
import { j as joinURL } from '../shared/nuxi.QWnQy_ku.mjs';
import { a as clearBuildDir } from '../shared/nuxi.CrvQqJcE.mjs';
import { l as loadKit } from '../shared/nuxi.BiWTNJI4.mjs';
import { l as loadNuxtManifest, r as resolveNuxtManifest, w as writeNuxtManifest } from '../shared/nuxi.DQbQuzNE.mjs';
import { readFile } from 'fs/promises';
import { inspect, debuglog } from 'util';
import os from 'node:os';
import tty__default from 'node:tty';
import { extname } from 'path';
import { g as getDefaultExportFromCjs } from '../shared/nuxi.BAGoDD49.mjs';
import { fileURLToPath } from 'url';
import { r as resolve } from '../shared/nuxi.Do0aYBCO.mjs';

function formatSocketURL(socketPath, ssl = false) {
  const protocol = ssl ? "https" : "http";
  const encodedPath = process$1.platform === "win32" ? encodeURIComponent(socketPath) : socketPath.replace(/\//g, "%2F");
  return `${protocol}+unix://${encodedPath}`;
}
function isSocketURL(url) {
  return url.startsWith("http+unix://") || url.startsWith("https+unix://");
}
function parseSocketURL(url) {
  if (!isSocketURL(url)) {
    throw new Error(`Invalid socket URL: ${url}`);
  }
  const ssl = url.startsWith("https+unix://");
  const path = url.slice(ssl ? "https+unix://".length : "http+unix://".length);
  const socketPath = decodeURIComponent(path.replace(/%2F/g, "/"));
  return { socketPath, protocol: ssl ? "https" : "http" };
}
async function createSocketListener(handler, proxyAddress) {
  const socketPath = getSocketAddress({
    name: "nuxt-dev",
    random: true
  });
  const server = new Server(handler);
  await cleanSocket(socketPath);
  await new Promise((resolve) => server.listen({ path: socketPath }, resolve));
  const url = formatSocketURL(socketPath);
  return {
    url,
    address: { address: "localhost", port: 3e3, ...proxyAddress, socketPath },
    async close() {
      try {
        server.removeAllListeners();
        await new Promise((resolve, reject) => server.close((err) => err ? reject(err) : resolve()));
      } finally {
        await cleanSocket(socketPath);
      }
    },
    getURLs: async () => [{ url, type: "network" }],
    https: false,
    server
  };
}

const DEBOUNCE_DEFAULTS = {
  trailing: true
};
function debounce(fn, wait = 25, options = {}) {
  options = { ...DEBOUNCE_DEFAULTS, ...options };
  if (!Number.isFinite(wait)) {
    throw new TypeError("Expected `wait` to be a finite number");
  }
  let leadingValue;
  let timeout;
  let resolveList = [];
  let currentPromise;
  let trailingArgs;
  const applyFn = (_this, args) => {
    currentPromise = _applyPromised(fn, _this, args);
    currentPromise.finally(() => {
      currentPromise = null;
      if (options.trailing && trailingArgs && !timeout) {
        const promise = applyFn(_this, trailingArgs);
        trailingArgs = null;
        return promise;
      }
    });
    return currentPromise;
  };
  return function(...args) {
    if (currentPromise) {
      if (options.trailing) {
        trailingArgs = args;
      }
      return currentPromise;
    }
    return new Promise((resolve) => {
      const shouldCallNow = !timeout && options.leading;
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        timeout = null;
        const promise = options.leading ? leadingValue : applyFn(this, args);
        for (const _resolve of resolveList) {
          _resolve(promise);
        }
        resolveList = [];
      }, wait);
      if (shouldCallNow) {
        leadingValue = applyFn(this, args);
        resolve(leadingValue);
      } else {
        resolveList.push(resolve);
      }
    });
  };
}
async function _applyPromised(fn, _this, args) {
  return await fn.apply(_this, args);
}

// src/public_dir.ts
var publicDirURL = new URL("./public/", import.meta.url);

// src/component.ts
var BaseComponent = class {
  #cachedStyles;
  #cachedScript;
  /**
   * A flag to know if we are in dev mode or not. In dev mode,
   * the styles and scripts are refetched from the disk.
   * Otherwise they are cached.
   */
  #inDevMode;
  /**
   * Absolute path to the frontend JavaScript that should be
   * injected within the HTML head. The JavaScript does not
   * get transpiled, hence it should work cross browser by
   * default.
   */
  scriptFile;
  /**
   * Absolute path to the CSS file that should be injected
   * within the HTML head.
   */
  cssFile;
  constructor(devMode) {
    this.#inDevMode = devMode;
  }
  /**
   * Returns the styles for the component. The null value
   * is not returned if no styles are associated with
   * the component
   */
  async getStyles() {
    if (!this.cssFile) {
      return null;
    }
    if (this.#inDevMode) {
      return await readFile(this.cssFile, "utf-8");
    }
    this.#cachedStyles = this.#cachedStyles ?? await readFile(this.cssFile, "utf-8");
    return this.#cachedStyles;
  }
  /**
   * Returns the frontend script for the component. The null
   * value is not returned if no styles are associated
   * with the component
   */
  async getScript() {
    if (!this.scriptFile) {
      return null;
    }
    if (this.#inDevMode) {
      return await readFile(this.scriptFile, "utf-8");
    }
    this.#cachedScript = this.#cachedScript ?? await readFile(this.scriptFile, "utf-8");
    return this.#cachedScript;
  }
};

// src/templates/layout/main.ts
var Layout = class extends BaseComponent {
  cssFile = new URL("./layout/style.css", publicDirURL);
  scriptFile = new URL("./layout/script.js", publicDirURL);
  /**
   * The toHTML method is used to output the HTML for the
   * web view
   */
  async toHTML(props) {
    return `<!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>${props.title}</title>
        <!-- STYLES -->
        <!-- SCRIPTS -->
      </head>
      <body>
        <div id="layout">
          ${await props.children()}
        </div>
      </body>
    </html>`;
  }
  /**
   * The toANSI method is used to output the text for the console
   */
  async toANSI(props) {
    return `
${await props.children()}
`;
  }
};

let FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY=true;
if (typeof process !== 'undefined') {
	({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
	isTTY = process.stdout && process.stdout.isTTY;
}

const $$2 = {
	enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (
		FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY
	),

	// modifiers
	reset: init(0, 0),
	bold: init(1, 22),
	dim: init(2, 22),
	italic: init(3, 23),
	underline: init(4, 24),
	inverse: init(7, 27),
	hidden: init(8, 28),
	strikethrough: init(9, 29),

	// colors
	black: init(30, 39),
	red: init(31, 39),
	green: init(32, 39),
	yellow: init(33, 39),
	blue: init(34, 39),
	magenta: init(35, 39),
	cyan: init(36, 39),
	white: init(37, 39),
	gray: init(90, 39),
	grey: init(90, 39),

	// background colors
	bgBlack: init(40, 49),
	bgRed: init(41, 49),
	bgGreen: init(42, 49),
	bgYellow: init(43, 49),
	bgBlue: init(44, 49),
	bgMagenta: init(45, 49),
	bgCyan: init(46, 49),
	bgWhite: init(47, 49)
};

function run(arr, str) {
	let i=0, tmp, beg='', end='';
	for (; i < arr.length; i++) {
		tmp = arr[i];
		beg += tmp.open;
		end += tmp.close;
		if (!!~str.indexOf(tmp.close)) {
			str = str.replace(tmp.rgx, tmp.close + tmp.open);
		}
	}
	return beg + str + end;
}

function chain(has, keys) {
	let ctx = { has, keys };

	ctx.reset = $$2.reset.bind(ctx);
	ctx.bold = $$2.bold.bind(ctx);
	ctx.dim = $$2.dim.bind(ctx);
	ctx.italic = $$2.italic.bind(ctx);
	ctx.underline = $$2.underline.bind(ctx);
	ctx.inverse = $$2.inverse.bind(ctx);
	ctx.hidden = $$2.hidden.bind(ctx);
	ctx.strikethrough = $$2.strikethrough.bind(ctx);

	ctx.black = $$2.black.bind(ctx);
	ctx.red = $$2.red.bind(ctx);
	ctx.green = $$2.green.bind(ctx);
	ctx.yellow = $$2.yellow.bind(ctx);
	ctx.blue = $$2.blue.bind(ctx);
	ctx.magenta = $$2.magenta.bind(ctx);
	ctx.cyan = $$2.cyan.bind(ctx);
	ctx.white = $$2.white.bind(ctx);
	ctx.gray = $$2.gray.bind(ctx);
	ctx.grey = $$2.grey.bind(ctx);

	ctx.bgBlack = $$2.bgBlack.bind(ctx);
	ctx.bgRed = $$2.bgRed.bind(ctx);
	ctx.bgGreen = $$2.bgGreen.bind(ctx);
	ctx.bgYellow = $$2.bgYellow.bind(ctx);
	ctx.bgBlue = $$2.bgBlue.bind(ctx);
	ctx.bgMagenta = $$2.bgMagenta.bind(ctx);
	ctx.bgCyan = $$2.bgCyan.bind(ctx);
	ctx.bgWhite = $$2.bgWhite.bind(ctx);

	return ctx;
}

function init(open, close) {
	let blk = {
		open: `\x1b[${open}m`,
		close: `\x1b[${close}m`,
		rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
	};
	return function (txt) {
		if (this !== void 0 && this.has !== void 0) {
			!!~this.has.indexOf(open) || (this.has.push(open),this.keys.push(blk));
			return txt === void 0 ? this : $$2.enabled ? run(this.keys, txt+'') : txt+'';
		}
		return txt === void 0 ? chain([open], [blk]) : $$2.enabled ? run([blk], txt+'') : txt+'';
	};
}

// src/base.ts
var Colors = class {
  black(text) {
    return this.transform("black", text);
  }
  red(text) {
    return this.transform("red", text);
  }
  green(text) {
    return this.transform("green", text);
  }
  yellow(text) {
    return this.transform("yellow", text);
  }
  blue(text) {
    return this.transform("blue", text);
  }
  magenta(text) {
    return this.transform("magenta", text);
  }
  cyan(text) {
    return this.transform("cyan", text);
  }
  white(text) {
    return this.transform("white", text);
  }
  gray(text) {
    return this.transform("gray", text);
  }
  grey(text) {
    return this.transform("grey", text);
  }
  bgBlack(text) {
    return this.transform("bgBlack", text);
  }
  bgRed(text) {
    return this.transform("bgRed", text);
  }
  bgGreen(text) {
    return this.transform("bgGreen", text);
  }
  bgYellow(text) {
    return this.transform("bgYellow", text);
  }
  bgBlue(text) {
    return this.transform("bgBlue", text);
  }
  bgMagenta(text) {
    return this.transform("bgMagenta", text);
  }
  bgCyan(text) {
    return this.transform("bgCyan", text);
  }
  bgWhite(text) {
    return this.transform("bgWhite", text);
  }
  reset(text) {
    return this.transform("reset", text);
  }
  bold(text) {
    return this.transform("bold", text);
  }
  dim(text) {
    return this.transform("dim", text);
  }
  italic(text) {
    return this.transform("italic", text);
  }
  underline(text) {
    return this.transform("underline", text);
  }
  inverse(text) {
    return this.transform("inverse", text);
  }
  hidden(text) {
    return this.transform("hidden", text);
  }
  strikethrough(text) {
    return this.transform("strikethrough", text);
  }
};

// src/raw.ts
var Raw = class extends Colors {
  #transformations = [];
  #dispose(value, callback) {
    callback();
    return value;
  }
  transform(transformation, text) {
    this.#transformations.push(transformation);
    if (text !== void 0) {
      const transformations = this.#transformations.concat([text]).join("(");
      const closingWrapping = new Array(this.#transformations.length + 1).join(")");
      return this.#dispose(`${transformations}${closingWrapping}`, () => {
        this.#transformations = [];
      });
    }
    return this;
  }
};
var Kleur = class extends Colors {
  #chain;
  constructor() {
    super();
    $$2.enabled = true;
  }
  #dispose(value, callback) {
    callback();
    return value;
  }
  transform(transformation, text) {
    if (text !== void 0) {
      if (this.#chain) {
        return this.#dispose(this.#chain[transformation](text), () => {
          this.#chain = void 0;
        });
      }
      return $$2[transformation](text);
    }
    if (this.#chain) {
      this.#chain = this.#chain[transformation]();
    } else {
      this.#chain = $$2[transformation]();
    }
    return this;
  }
};

// src/silent.ts
var Silent = class extends Colors {
  transform(_, text) {
    if (text !== void 0) {
      return String(text);
    }
    return this;
  }
};

// index.ts
var useColors = {
  /**
   * Kleur implementation
   */
  ansi() {
    return new Kleur();
  },
  /**
   * Silent implementation. Returns the string
   * as it is
   */
  silent() {
    return new Silent();
  },
  /**
   * Raw implementation. Wraps string with applied
   * transformations as plain text.
   */
  raw() {
    return new Raw();
  }
};
var index_default = useColors;

// src/helpers.ts
var ANSI_REGEX = new RegExp(
  [
    `[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))`,
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|"),
  "g"
);
function htmlEscape$1(value) {
  return value.replace(/&/g, "&amp;").replace(/\\"/g, "&bsol;&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function wordWrap$1(value, options) {
  const width = options.width;
  const indent = options.indent;
  const newLine = `${options.newLine}${indent}`;
  if (!width) {
    return options.escape ? options.escape(value) : htmlEscape$1(value);
  }
  let regexString = ".{1," + width + "}";
  regexString += "([\\s\u200B]+|$)|[^\\s\u200B]+?([\\s\u200B]+|$)";
  const re = new RegExp(regexString, "g");
  const lines = value.match(re) || [];
  const result = lines.map(function(line) {
    if (line.slice(-1) === "\n") {
      line = line.slice(0, line.length - 1);
    }
    return options.escape ? options.escape(line) : htmlEscape$1(line);
  }).join(newLine);
  return result;
}
function stripAnsi(value) {
  return value.replace(ANSI_REGEX, "");
}
var colors$1 = index_default.ansi();

const typedArrayTypeNames = [
    'Int8Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'Int16Array',
    'Uint16Array',
    'Int32Array',
    'Uint32Array',
    'Float32Array',
    'Float64Array',
    'BigInt64Array',
    'BigUint64Array',
];
function isTypedArrayName(name) {
    return typedArrayTypeNames.includes(name);
}
const objectTypeNames = [
    'Function',
    'Generator',
    'AsyncGenerator',
    'GeneratorFunction',
    'AsyncGeneratorFunction',
    'AsyncFunction',
    'Observable',
    'Array',
    'Buffer',
    'Blob',
    'Object',
    'RegExp',
    'Date',
    'Error',
    'Map',
    'Set',
    'WeakMap',
    'WeakSet',
    'WeakRef',
    'ArrayBuffer',
    'SharedArrayBuffer',
    'DataView',
    'Promise',
    'URL',
    'FormData',
    'URLSearchParams',
    'HTMLElement',
    'NaN',
    ...typedArrayTypeNames,
];
function isObjectTypeName(name) {
    return objectTypeNames.includes(name);
}
const primitiveTypeNames = [
    'null',
    'undefined',
    'string',
    'number',
    'bigint',
    'boolean',
    'symbol',
];
function isPrimitiveTypeName(name) {
    return primitiveTypeNames.includes(name);
}
const getObjectType = (value) => {
    const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
    if (/HTML\w+Element/.test(objectTypeName) && isHtmlElement(value)) {
        return 'HTMLElement';
    }
    if (isObjectTypeName(objectTypeName)) {
        return objectTypeName;
    }
    return undefined;
};
function detect(value) {
    if (value === null) {
        return 'null';
    }
    switch (typeof value) {
        case 'undefined': {
            return 'undefined';
        }
        case 'string': {
            return 'string';
        }
        case 'number': {
            return Number.isNaN(value) ? 'NaN' : 'number';
        }
        case 'boolean': {
            return 'boolean';
        }
        case 'function': {
            return 'Function';
        }
        case 'bigint': {
            return 'bigint';
        }
        case 'symbol': {
            return 'symbol';
        }
    }
    if (isObservable(value)) {
        return 'Observable';
    }
    if (isArray(value)) {
        return 'Array';
    }
    if (isBuffer(value)) {
        return 'Buffer';
    }
    const tagType = getObjectType(value);
    if (tagType) {
        return tagType;
    }
    if (value instanceof String || value instanceof Boolean || value instanceof Number) {
        throw new TypeError('Please don\'t use object wrappers for primitive types');
    }
    return 'Object';
}
function hasPromiseApi(value) {
    return isFunction(value?.then) && isFunction(value?.catch);
}
const is = Object.assign(detect, {
    all: isAll,
    any: isAny,
    array: isArray,
    arrayBuffer: isArrayBuffer,
    arrayLike: isArrayLike,
    asyncFunction: isAsyncFunction,
    asyncGenerator: isAsyncGenerator,
    asyncGeneratorFunction: isAsyncGeneratorFunction,
    asyncIterable: isAsyncIterable,
    bigint: isBigint,
    bigInt64Array: isBigInt64Array,
    bigUint64Array: isBigUint64Array,
    blob: isBlob,
    boolean: isBoolean,
    boundFunction: isBoundFunction,
    buffer: isBuffer,
    class: isClass,
    dataView: isDataView,
    date: isDate,
    detect,
    directInstanceOf: isDirectInstanceOf,
    emptyArray: isEmptyArray,
    emptyMap: isEmptyMap,
    emptyObject: isEmptyObject,
    emptySet: isEmptySet,
    emptyString: isEmptyString,
    emptyStringOrWhitespace: isEmptyStringOrWhitespace,
    enumCase: isEnumCase,
    error: isError,
    evenInteger: isEvenInteger,
    falsy: isFalsy,
    float32Array: isFloat32Array,
    float64Array: isFloat64Array,
    formData: isFormData,
    function: isFunction,
    generator: isGenerator,
    generatorFunction: isGeneratorFunction,
    htmlElement: isHtmlElement,
    infinite: isInfinite,
    inRange: isInRange,
    int16Array: isInt16Array,
    int32Array: isInt32Array,
    int8Array: isInt8Array,
    integer: isInteger,
    iterable: isIterable,
    map: isMap,
    nan: isNan,
    nativePromise: isNativePromise,
    negativeNumber: isNegativeNumber,
    nodeStream: isNodeStream,
    nonEmptyArray: isNonEmptyArray,
    nonEmptyMap: isNonEmptyMap,
    nonEmptyObject: isNonEmptyObject,
    nonEmptySet: isNonEmptySet,
    nonEmptyString: isNonEmptyString,
    nonEmptyStringAndNotWhitespace: isNonEmptyStringAndNotWhitespace,
    null: isNull,
    nullOrUndefined: isNullOrUndefined,
    number: isNumber,
    numericString: isNumericString,
    object: isObject,
    observable: isObservable,
    oddInteger: isOddInteger,
    plainObject: isPlainObject,
    positiveNumber: isPositiveNumber,
    primitive: isPrimitive,
    promise: isPromise,
    propertyKey: isPropertyKey,
    regExp: isRegExp,
    safeInteger: isSafeInteger,
    set: isSet,
    sharedArrayBuffer: isSharedArrayBuffer,
    string: isString,
    symbol: isSymbol,
    truthy: isTruthy,
    tupleLike: isTupleLike,
    typedArray: isTypedArray,
    uint16Array: isUint16Array,
    uint32Array: isUint32Array,
    uint8Array: isUint8Array,
    uint8ClampedArray: isUint8ClampedArray,
    undefined: isUndefined,
    urlInstance: isUrlInstance,
    urlSearchParams: isUrlSearchParams,
    urlString: isUrlString,
    validDate: isValidDate,
    validLength: isValidLength,
    weakMap: isWeakMap,
    weakRef: isWeakRef,
    weakSet: isWeakSet,
    whitespaceString: isWhitespaceString,
});
function isAbsoluteModule2(remainder) {
    return (value) => isInteger(value) && Math.abs(value % 2) === remainder;
}
function isAll(predicate, ...values) {
    return predicateOnArray(Array.prototype.every, predicate, values);
}
function isAny(predicate, ...values) {
    const predicates = isArray(predicate) ? predicate : [predicate];
    return predicates.some(singlePredicate => predicateOnArray(Array.prototype.some, singlePredicate, values));
}
function isArray(value, assertion) {
    if (!Array.isArray(value)) {
        return false;
    }
    if (!isFunction(assertion)) {
        return true;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    return value.every(element => assertion(element));
}
function isArrayBuffer(value) {
    return getObjectType(value) === 'ArrayBuffer';
}
function isArrayLike(value) {
    return !isNullOrUndefined(value) && !isFunction(value) && isValidLength(value.length);
}
function isAsyncFunction(value) {
    return getObjectType(value) === 'AsyncFunction';
}
function isAsyncGenerator(value) {
    return isAsyncIterable(value) && isFunction(value.next) && isFunction(value.throw);
}
function isAsyncGeneratorFunction(value) {
    return getObjectType(value) === 'AsyncGeneratorFunction';
}
function isAsyncIterable(value) {
    return isFunction(value?.[Symbol.asyncIterator]);
}
function isBigint(value) {
    return typeof value === 'bigint';
}
function isBigInt64Array(value) {
    return getObjectType(value) === 'BigInt64Array';
}
function isBigUint64Array(value) {
    return getObjectType(value) === 'BigUint64Array';
}
function isBlob(value) {
    return getObjectType(value) === 'Blob';
}
function isBoolean(value) {
    return value === true || value === false;
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isBoundFunction(value) {
    return isFunction(value) && !Object.hasOwn(value, 'prototype');
}
/**
Note: [Prefer using `Uint8Array` instead of `Buffer`.](https://sindresorhus.com/blog/goodbye-nodejs-buffer)
*/
function isBuffer(value) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call
    return value?.constructor?.isBuffer?.(value) ?? false;
}
function isClass(value) {
    return isFunction(value) && value.toString().startsWith('class ');
}
function isDataView(value) {
    return getObjectType(value) === 'DataView';
}
function isDate(value) {
    return getObjectType(value) === 'Date';
}
function isDirectInstanceOf(instance, class_) {
    if (instance === undefined || instance === null) {
        return false;
    }
    return Object.getPrototypeOf(instance) === class_.prototype;
}
function isEmptyArray(value) {
    return isArray(value) && value.length === 0;
}
function isEmptyMap(value) {
    return isMap(value) && value.size === 0;
}
function isEmptyObject(value) {
    return isObject(value) && !isMap(value) && !isSet(value) && Object.keys(value).length === 0;
}
function isEmptySet(value) {
    return isSet(value) && value.size === 0;
}
function isEmptyString(value) {
    return isString(value) && value.length === 0;
}
function isEmptyStringOrWhitespace(value) {
    return isEmptyString(value) || isWhitespaceString(value);
}
function isEnumCase(value, targetEnum) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    return Object.values(targetEnum).includes(value);
}
function isError(value) {
    // TODO: Use `Error.isError` when targeting Node.js 24.`
    return getObjectType(value) === 'Error';
}
function isEvenInteger(value) {
    return isAbsoluteModule2(0)(value);
}
// Example: `is.falsy = (value: unknown): value is (not true | 0 | '' | undefined | null) => Boolean(value);`
function isFalsy(value) {
    return !value;
}
// TODO: Support detecting Float16Array when targeting Node.js 24.
function isFloat32Array(value) {
    return getObjectType(value) === 'Float32Array';
}
function isFloat64Array(value) {
    return getObjectType(value) === 'Float64Array';
}
function isFormData(value) {
    return getObjectType(value) === 'FormData';
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isFunction(value) {
    return typeof value === 'function';
}
function isGenerator(value) {
    return isIterable(value) && isFunction(value?.next) && isFunction(value?.throw);
}
function isGeneratorFunction(value) {
    return getObjectType(value) === 'GeneratorFunction';
}
// eslint-disable-next-line @typescript-eslint/naming-convention
const NODE_TYPE_ELEMENT = 1;
// eslint-disable-next-line @typescript-eslint/naming-convention
const DOM_PROPERTIES_TO_CHECK = [
    'innerHTML',
    'ownerDocument',
    'style',
    'attributes',
    'nodeValue',
];
function isHtmlElement(value) {
    return isObject(value)
        && value.nodeType === NODE_TYPE_ELEMENT
        && isString(value.nodeName)
        && !isPlainObject(value)
        && DOM_PROPERTIES_TO_CHECK.every(property => property in value);
}
function isInfinite(value) {
    return value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY;
}
function isInRange(value, range) {
    if (isNumber(range)) {
        return value >= Math.min(0, range) && value <= Math.max(range, 0);
    }
    if (isArray(range) && range.length === 2) {
        return value >= Math.min(...range) && value <= Math.max(...range);
    }
    throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
}
function isInt16Array(value) {
    return getObjectType(value) === 'Int16Array';
}
function isInt32Array(value) {
    return getObjectType(value) === 'Int32Array';
}
function isInt8Array(value) {
    return getObjectType(value) === 'Int8Array';
}
function isInteger(value) {
    return Number.isInteger(value);
}
function isIterable(value) {
    return isFunction(value?.[Symbol.iterator]);
}
function isMap(value) {
    return getObjectType(value) === 'Map';
}
function isNan(value) {
    return Number.isNaN(value);
}
function isNativePromise(value) {
    return getObjectType(value) === 'Promise';
}
function isNegativeNumber(value) {
    return isNumber(value) && value < 0;
}
function isNodeStream(value) {
    return isObject(value) && isFunction(value.pipe) && !isObservable(value);
}
function isNonEmptyArray(value) {
    return isArray(value) && value.length > 0;
}
function isNonEmptyMap(value) {
    return isMap(value) && value.size > 0;
}
// TODO: Use `not` operator here to remove `Map` and `Set` from type guard:
// - https://github.com/Microsoft/TypeScript/pull/29317
function isNonEmptyObject(value) {
    return isObject(value) && !isMap(value) && !isSet(value) && Object.keys(value).length > 0;
}
function isNonEmptySet(value) {
    return isSet(value) && value.size > 0;
}
// TODO: Use `not ''` when the `not` operator is available.
function isNonEmptyString(value) {
    return isString(value) && value.length > 0;
}
// TODO: Use `not ''` when the `not` operator is available.
function isNonEmptyStringAndNotWhitespace(value) {
    return isString(value) && !isEmptyStringOrWhitespace(value);
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isNull(value) {
    return value === null;
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isNullOrUndefined(value) {
    return isNull(value) || isUndefined(value);
}
function isNumber(value) {
    return typeof value === 'number' && !Number.isNaN(value);
}
function isNumericString(value) {
    return isString(value) && !isEmptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(value) {
    return !isNull(value) && (typeof value === 'object' || isFunction(value));
}
function isObservable(value) {
    if (!value) {
        return false;
    }
    // eslint-disable-next-line no-use-extend-native/no-use-extend-native, @typescript-eslint/no-unsafe-call
    if (Symbol.observable !== undefined && value === value[Symbol.observable]?.()) {
        return true;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    if (value === value['@@observable']?.()) {
        return true;
    }
    return false;
}
function isOddInteger(value) {
    return isAbsoluteModule2(1)(value);
}
function isPlainObject(value) {
    // From: https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function isPositiveNumber(value) {
    return isNumber(value) && value > 0;
}
function isPrimitive(value) {
    return isNull(value) || isPrimitiveTypeName(typeof value);
}
function isPromise(value) {
    return isNativePromise(value) || hasPromiseApi(value);
}
// `PropertyKey` is any value that can be used as an object key (string, number, or symbol)
function isPropertyKey(value) {
    return isAny([isString, isNumber, isSymbol], value);
}
function isRegExp(value) {
    return getObjectType(value) === 'RegExp';
}
function isSafeInteger(value) {
    return Number.isSafeInteger(value);
}
function isSet(value) {
    return getObjectType(value) === 'Set';
}
function isSharedArrayBuffer(value) {
    return getObjectType(value) === 'SharedArrayBuffer';
}
function isString(value) {
    return typeof value === 'string';
}
function isSymbol(value) {
    return typeof value === 'symbol';
}
// Example: `is.truthy = (value: unknown): value is (not false | not 0 | not '' | not undefined | not null) => Boolean(value);`
// eslint-disable-next-line unicorn/prefer-native-coercion-functions
function isTruthy(value) {
    return Boolean(value);
}
function isTupleLike(value, guards) {
    if (isArray(guards) && isArray(value) && guards.length === value.length) {
        return guards.every((guard, index) => guard(value[index]));
    }
    return false;
}
function isTypedArray(value) {
    return isTypedArrayName(getObjectType(value));
}
function isUint16Array(value) {
    return getObjectType(value) === 'Uint16Array';
}
function isUint32Array(value) {
    return getObjectType(value) === 'Uint32Array';
}
function isUint8Array(value) {
    return getObjectType(value) === 'Uint8Array';
}
function isUint8ClampedArray(value) {
    return getObjectType(value) === 'Uint8ClampedArray';
}
function isUndefined(value) {
    return value === undefined;
}
function isUrlInstance(value) {
    return getObjectType(value) === 'URL';
}
// eslint-disable-next-line unicorn/prevent-abbreviations
function isUrlSearchParams(value) {
    return getObjectType(value) === 'URLSearchParams';
}
function isUrlString(value) {
    if (!isString(value)) {
        return false;
    }
    try {
        new URL(value); // eslint-disable-line no-new
        return true;
    }
    catch {
        return false;
    }
}
function isValidDate(value) {
    return isDate(value) && !isNan(Number(value));
}
function isValidLength(value) {
    return isSafeInteger(value) && value >= 0;
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isWeakMap(value) {
    return getObjectType(value) === 'WeakMap';
}
// eslint-disable-next-line @typescript-eslint/ban-types, unicorn/prevent-abbreviations
function isWeakRef(value) {
    return getObjectType(value) === 'WeakRef';
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isWeakSet(value) {
    return getObjectType(value) === 'WeakSet';
}
function isWhitespaceString(value) {
    return isString(value) && /^\s+$/.test(value);
}
function predicateOnArray(method, predicate, values) {
    if (!isFunction(predicate)) {
        throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
    }
    if (values.length === 0) {
        throw new TypeError('Invalid number of values');
    }
    return method.call(values, predicate);
}

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/helpers.ts
var helpers_exports = {};
__export(helpers_exports, {
  htmlEscape: () => htmlEscape,
  tokenizeArray: () => tokenizeArray,
  tokenizeObject: () => tokenizeObject,
  tokenizePrototype: () => tokenizePrototype,
  wordWrap: () => wordWrap
});
var ObjectPrototype = Object.prototype;
var ArrayPrototype = Array.prototype;
var ObjectPrototypeKeys = Reflect.ownKeys(ObjectPrototype);
var ArrayPrototypeKeys = Reflect.ownKeys(ArrayPrototype);
function tokenizeObject(value, parser, config) {
  parser.context.objectsSeen = parser.context.objectsSeen ?? /* @__PURE__ */ new Set();
  parser.context.depth = parser.context.depth ?? 0;
  if (parser.context.objectsSeen.has(value)) {
    parser.collect({ type: "object-circular-ref" });
    return;
  }
  if (parser.context.depth >= parser.config.depth) {
    parser.collect({ type: "object-max-depth-ref" });
    return;
  }
  const showHidden = config.showHidden;
  const name = config.constructorName ?? Object.getPrototypeOf(value)?.constructor.name ?? null;
  if (config.collapse.includes(name)) {
    parser.collect({
      type: "collapse",
      name,
      token: {
        type: "object-start",
        constructorName: name
      }
    });
    return;
  }
  const ownKeys = Reflect.ownKeys(value);
  const eagerGetters = config.eagerGetters ?? [];
  parser.context.depth++;
  parser.context.objectsSeen.add(value);
  let keys = [];
  if (config.membersToIgnore) {
    const keysSet = /* @__PURE__ */ new Set([...ownKeys]);
    config.membersToIgnore.forEach((m) => keysSet.delete(m));
    keys = Array.from(keysSet);
  } else {
    keys = ownKeys;
  }
  parser.collect({ type: "object-start", constructorName: name });
  for (let key of keys) {
    const descriptor = Object.getOwnPropertyDescriptor(value, key);
    if (!descriptor) {
      continue;
    }
    if (!descriptor.enumerable && !showHidden) {
      continue;
    }
    const isSymbol = typeof key === "symbol";
    const isWritable = !!descriptor.set || !!descriptor.writable;
    parser.collect({
      type: "object-key",
      isSymbol,
      isWritable,
      value: String(key)
    });
    if ("get" in descriptor && !eagerGetters.includes(key)) {
      parser.collect({ type: "object-value-getter" });
      continue;
    }
    parser.collect({ type: "object-value-start" });
    parser.parse(value[key]);
    parser.collect({ type: "object-value-end" });
  }
  if (config.inspectObjectPrototype === true) {
    tokenizePrototype(value, parser, {
      membersToIgnore: ObjectPrototypeKeys
    });
  } else if (config.inspectObjectPrototype === "unless-plain-object" && !is.plainObject(value)) {
    tokenizePrototype(value, parser, {
      membersToIgnore: ObjectPrototypeKeys,
      prototypeToIgnore: ObjectPrototype
    });
  }
  parser.collect({ type: "object-end" });
  parser.context.depth--;
  parser.context.objectsSeen.delete(value);
}
function tokenizePrototype(value, parser, config) {
  const prototypeChain = [];
  for (let proto = Object.getPrototypeOf(value); proto && (!config.prototypeToIgnore || proto !== config.prototypeToIgnore); proto = Object.getPrototypeOf(proto)) {
    let keys = Reflect.ownKeys(proto);
    if (config.membersToIgnore) {
      const keysSet = /* @__PURE__ */ new Set([...keys]);
      config.membersToIgnore.forEach((m) => keysSet.delete(m));
      keys = Array.from(keysSet);
    }
    prototypeChain.push({ proto, keys });
  }
  if (!prototypeChain.length) {
    return;
  }
  const eagerGetters = config.eagerGetters ?? [];
  parser.collect({ type: "prototype-start" });
  for (let proto of prototypeChain) {
    for (let key of proto.keys) {
      if (key === "constructor") {
        continue;
      }
      const descriptor = Object.getOwnPropertyDescriptor(proto.proto, key);
      if (!descriptor) {
        continue;
      }
      const isSymbol = typeof key === "symbol";
      const isWritable = !!descriptor.set || !!descriptor.writable;
      parser.collect({
        type: "object-key",
        isSymbol,
        isWritable,
        value: String(key)
      });
      if ("get" in descriptor && !eagerGetters.includes(key)) {
        parser.collect({ type: "object-value-getter" });
        continue;
      }
      parser.collect({ type: "object-value-start" });
      parser.parse(value[key]);
      parser.collect({ type: "object-value-end" });
    }
  }
  parser.collect({ type: "prototype-end" });
}
function tokenizeArray(values, parser, config) {
  parser.context.arraysSeen = parser.context.arraysSeen ?? /* @__PURE__ */ new Set();
  parser.context.depth = parser.context.depth ?? 0;
  if (parser.context.arraysSeen.has(values)) {
    parser.collect({ type: "array-circular-ref" });
    return;
  }
  if (parser.context.depth >= config.depth) {
    parser.collect({ type: "array-max-depth-ref" });
    return;
  }
  const limit = config.maxArrayLength;
  const size = values.length;
  const name = config.name || values.constructor.name;
  if (config.collapse.includes(name)) {
    parser.collect({
      type: "collapse",
      name,
      token: {
        type: "array-start",
        name,
        size
      }
    });
    return;
  }
  parser.context.depth++;
  parser.context.arraysSeen.add(values);
  parser.collect({ type: "array-start", name, size });
  for (let index = 0; index < size; index++) {
    if (index >= limit) {
      parser.collect({ type: "array-max-length-ref", limit, size });
      break;
    }
    const value = values[index];
    if (Object.hasOwn(values, index)) {
      parser.collect({ type: "array-value-start", index });
      parser.parse(value);
      parser.collect({ type: "array-value-end", index });
    } else {
      parser.collect({ type: "array-value-hole", index });
    }
  }
  if (config.inspectArrayPrototype) {
    tokenizePrototype(values, parser, {
      membersToIgnore: ArrayPrototypeKeys,
      prototypeToIgnore: ArrayPrototype
    });
  }
  parser.collect({ type: "array-end", size });
  parser.context.depth--;
  parser.context.arraysSeen.delete(values);
}
function htmlEscape(value) {
  return value.replace(/&/g, "&amp;").replace(/\\"/g, "&bsol;&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function wordWrap(value, options) {
  const width = options.width;
  const indent = options.indent;
  const newLine = `${options.newLine}${indent}`;
  let regexString = ".{1," + width + "}";
  regexString += "([\\s\u200B]+|$)|[^\\s\u200B]+?([\\s\u200B]+|$)";
  const re = new RegExp(regexString, "g");
  const lines = value.match(re) || [];
  const result = lines.map(function(line) {
    if (line.slice(-1) === "\n") {
      line = line.slice(0, line.length - 1);
    }
    return options.escape ? options.escape(line) : htmlEscape(line);
  }).join(newLine);
  return result;
}
var tokenizers = {
  /**
   * Tokenizes an object and its properties.
   *  - Enable "showHidden" option to parse non-enumerable
   *  - Enable "inspectObjectPrototype" to parse prototype members
   */
  Object: (value, parser) => {
    tokenizeObject(value, parser, parser.config);
  },
  /**
   * Tokenizes an array of values
   */
  Array: (values, parser) => {
    tokenizeArray(values, parser, parser.config);
  },
  /**
   * Tokenizes keys and values inside a map
   */
  Map: (values, parser) => {
    parser.context.mapsSeen = parser.context.mapsSeen ?? /* @__PURE__ */ new Set();
    parser.context.depth = parser.context.depth ?? 0;
    if (parser.context.mapsSeen.has(values)) {
      parser.collect({ type: "map-circular-ref" });
      return;
    }
    if (parser.context.depth >= parser.config.depth) {
      parser.collect({ type: "map-max-depth-ref" });
      return;
    }
    parser.context.depth++;
    parser.context.mapsSeen.add(values);
    let index = 0;
    const size = values.size;
    const limit = parser.config.maxArrayLength;
    parser.collect({ type: "map-start", size });
    for (let [key, value] of values) {
      if (index >= limit) {
        parser.collect({ type: "map-max-length-ref", limit, size });
        break;
      }
      parser.collect({ type: "map-row-start", index });
      parser.collect({ type: "map-key-start", index });
      parser.parse(key);
      parser.collect({ type: "map-key-end", index });
      parser.collect({ type: "map-value-start", index });
      parser.parse(value);
      parser.collect({ type: "map-value-end", index });
      parser.collect({ type: "map-row-end", index });
      index++;
    }
    parser.collect({ type: "map-end", size });
    parser.context.depth--;
    parser.context.mapsSeen.delete(values);
  },
  /**
   * Tokenizes values inside a set
   */
  Set: (values, parser) => {
    parser.context.setsSeen = parser.context.setsSeen ?? /* @__PURE__ */ new Set();
    parser.context.depth = parser.context.depth ?? 0;
    if (parser.context.setsSeen.has(values)) {
      parser.collect({ type: "set-circular-ref" });
      return;
    }
    if (parser.context.depth >= parser.config.depth) {
      parser.collect({ type: "set-max-depth-ref" });
      return;
    }
    parser.context.depth++;
    parser.context.setsSeen.add(values);
    let index = 0;
    const size = values.size;
    const limit = parser.config.maxArrayLength;
    parser.collect({ type: "set-start", size });
    for (let value of values) {
      if (index >= limit) {
        parser.collect({ type: "set-max-length-ref", limit, size });
        break;
      }
      parser.collect({ type: "set-value-start", index });
      parser.parse(value);
      parser.collect({ type: "set-value-end", index });
      index++;
    }
    parser.collect({ type: "set-end", size });
    parser.context.depth--;
    parser.context.setsSeen.delete(values);
  },
  /**
   * Tokenizes a function. If the function is a class created
   * using the [class] keyword, we will process its static
   * members when "config.inspectClassConstructor"
   * is enabled
   */
  Function: (value, parser) => {
    const ConstructorName = value.constructor.name;
    if (ConstructorName === "GeneratorFunction") {
      return tokenizers.GeneratorFunction(value, parser);
    }
    if (ConstructorName === "AsyncGeneratorFunction") {
      return tokenizers.AsyncGeneratorFunction(value, parser);
    }
    if (ConstructorName === "AsyncFunction") {
      return tokenizers.AsyncFunction(value, parser);
    }
    const isClass = is.class(value);
    parser.collect({
      type: "function",
      isClass,
      isAsync: false,
      isGenerator: false,
      name: value.name || "anonymous"
    });
    if (parser.config.inspectStaticMembers && isClass) {
      parser.collect({ type: "static-members-start" });
      tokenizeObject(value, parser, {
        showHidden: true,
        depth: parser.config.depth,
        inspectObjectPrototype: false,
        collapse: parser.config.collapse,
        membersToIgnore: ["prototype", "name", "length"]
      });
      parser.collect({ type: "static-members-end" });
    }
  },
  /**
   * Tokenizes a string value and handles max length and
   * correct quotes via the "util.inspect" method.
   */
  string: (value, parser) => {
    const formatted = inspect(value, {
      maxStringLength: parser.config.maxStringLength,
      customInspect: false
    });
    parser.collect({ type: "string", value: formatted });
  },
  /**
   * Tokenizes the URL instance as an object
   */
  URL: (value, parser) => {
    tokenizeObject(
      {
        hash: value.hash,
        host: value.host,
        hostname: value.hostname,
        href: value.href,
        origin: value.origin,
        password: value.password,
        pathname: value.pathname,
        port: value.port,
        protocol: value.protocol,
        search: value.search,
        searchParams: value.searchParams,
        username: value.username
      },
      parser,
      { constructorName: "URL", ...parser.config }
    );
  },
  /**
   * Tokenizes the URLSearchParams instance as an object
   */
  URLSearchParams: (value, parser) => {
    tokenizeObject(Object.fromEntries(value), parser, {
      constructorName: "URLSearchParams",
      ...parser.config
    });
  },
  Error: function(value, parser) {
    tokenizeObject(value, parser, {
      eagerGetters: ["message", "stack"],
      ...parser.config,
      inspectObjectPrototype: parser.config.inspectObjectPrototype === true ? true : false,
      showHidden: true
    });
  },
  FormData: function(value, parser) {
    tokenizeObject(Object.fromEntries(value.entries()), parser, {
      constructorName: "FormData",
      ...parser.config
    });
  },
  /**
   * Straight forward one's
   */
  undefined: (_, parser) => {
    parser.collect({ type: "undefined" });
  },
  null: (_, parser) => {
    parser.collect({ type: "null" });
  },
  symbol: (value, parser) => {
    parser.collect({ type: "symbol", value: String(value) });
  },
  number: (value, parser) => {
    parser.collect({ type: "number", value });
  },
  boolean: (value, parser) => {
    parser.collect({ type: "boolean", value });
  },
  bigint: (value, parser) => {
    parser.collect({ type: "bigInt", value: `${value.toString()}n` });
  },
  Date: (value, parser) => {
    parser.collect({ type: "date", value: value.toISOString() });
  },
  RegExp: (value, parser) => {
    parser.collect({ type: "regexp", value: String(value) });
  },
  Buffer: (value, parser) => {
    parser.collect({
      type: "buffer",
      value: inspect(value)
    });
  },
  WeakSet: (_, parser) => {
    parser.collect({ type: "weak-set" });
  },
  WeakMap: (_, parser) => {
    parser.collect({ type: "weak-map" });
  },
  WeakRef: function(_, parser) {
    parser.collect({ type: "weak-ref" });
  },
  Generator: function(_, parser) {
    parser.collect({ type: "generator", isAsync: false });
  },
  AsyncGenerator: function(_, parser) {
    parser.collect({ type: "generator", isAsync: true });
  },
  GeneratorFunction: function(value, parser) {
    parser.collect({
      type: "function",
      isGenerator: true,
      isClass: false,
      isAsync: false,
      name: value.name || "anonymous"
    });
  },
  AsyncGeneratorFunction: function(value, parser) {
    parser.collect({
      type: "function",
      isGenerator: true,
      isClass: false,
      isAsync: true,
      name: value.name || "anonymous"
    });
  },
  AsyncFunction: function(value, parser) {
    parser.collect({
      type: "function",
      isGenerator: false,
      isClass: false,
      isAsync: true,
      name: value.name || "anonymous"
    });
  },
  Observable: function(_, parser) {
    parser.collect({ type: "observable" });
  },
  Blob: function(value, parser) {
    parser.collect({ type: "blob", size: value.size, contentType: value.type });
  },
  Promise: function(value, parser) {
    parser.collect({
      type: "promise",
      isFulfilled: !inspect(value).includes("pending")
    });
  },
  NaN: function(_, parser) {
    parser.collect({ type: "number", value: Number.NaN });
  },
  Int8Array: function(value, parser) {
    tokenizeArray(value, parser, parser.config);
  },
  Uint8Array: function(value, parser) {
    tokenizeArray(value, parser, parser.config);
  },
  Int16Array: function(value, parser) {
    tokenizeArray(value, parser, parser.config);
  },
  Uint16Array: function(value, parser) {
    tokenizeArray(value, parser, parser.config);
  },
  Int32Array: function(value, parser) {
    tokenizeArray(value, parser, parser.config);
  },
  Uint32Array: function(value, parser) {
    tokenizeArray(value, parser, parser.config);
  },
  Float32Array: function(value, parser) {
    tokenizeArray(value, parser, parser.config);
  },
  Float64Array: function(value, parser) {
    tokenizeArray(value, parser, parser.config);
  },
  BigInt64Array: function(value, parser) {
    tokenizeArray(value, parser, parser.config);
  },
  BigUint64Array: function(value, parser) {
    tokenizeArray(value, parser, parser.config);
  }
};
var Parser = class {
  #tokens = [];
  /**
   * Config shared with tokenizers
   */
  config;
  /**
   * Context maintained through out the parsing phase.
   * Each instance of Parser has its own context
   * that gets mutated internally.
   */
  context;
  constructor(config, context) {
    this.context = context || {};
    this.config = Object.freeze({
      showHidden: false,
      depth: 5,
      inspectObjectPrototype: "unless-plain-object",
      inspectArrayPrototype: false,
      inspectStaticMembers: false,
      maxArrayLength: 100,
      maxStringLength: 1e3,
      collapse: [],
      ...config
    });
  }
  /**
   * Normalizes the type name of a property using additional
   * bit of checks. For example, the "is" module does not
   * use instanceOf checks and hence misses out on many
   * potentional improvements.
   */
  #normalizeTypeName(name, value) {
    if (name === "Object" && value instanceof Error) {
      return "Error";
    }
    return name;
  }
  /**
   * Collect a token inside the list of tokens. The order
   * of tokens matter during printing therefore you must
   * collect tokens in the right order.
   */
  collect(token) {
    this.#tokens.push(token);
  }
  /**
   * Parses a value using the tokenizers. Under the hood the
   * tokenizers will call "parser.collect" to collect
   * tokens inside an array.
   *
   * You can use "parser.flush" method to get the list of
   * tokens.
   */
  parse(value) {
    const typeName = this.#normalizeTypeName(is.detect(value), value);
    const tokenizer = tokenizers[typeName];
    if (tokenizer) {
      tokenizer(value, this);
    } else {
      this.collect({ type: "unknown", jsType: typeName, value });
    }
  }
  /**
   * Returns collected tokens and resets the internal state.
   */
  flush() {
    const tokens = this.#tokens;
    this.#tokens = [];
    this.context = {};
    return tokens;
  }
};

// formatters/html/themes.ts
var themes$1 = {
  nightOwl: {
    pre: "background-color: #061626; color: #c792ea;",
    toggle: "color: #4f5357; background: none; border: none;",
    braces: "color: #ffd700;",
    brackets: "color: #ffd700;",
    number: "color: #f78c6c;",
    bigInt: "color: #f78c6c; font-weight: bold;",
    boolean: "color: #ff5874; font-style: italic;",
    string: "color: #ecc48d;",
    null: "color: #637777;",
    undefined: "color: #637777;",
    prototypeLabel: "color: #637777;",
    symbol: "color: #82aaff;",
    regex: "color: #ff5874;",
    date: "color: #7fdbca;",
    buffer: "color: #7fdbca;",
    functionLabel: "color: #89b4fa;",
    arrayLabel: "color: #82aaff;",
    objectLabel: "color: #82aaff;",
    mapLabel: "color: #82aaff;",
    setLabel: "color: #82aaff;",
    objectKey: "color: #c792ea;",
    objectKeyPrefix: "color: #637777; font-style: italic; font-weight: bold",
    classLabel: "color: #82aaff;",
    collapseLabel: "color: #7fdbca; font-style: italic;",
    getterLabel: "color: #7fdbca;",
    circularLabel: "color: #7fdbca;",
    weakSetLabel: "color: #7fdbca;",
    weakRefLabel: "color: #7fdbca;",
    weakMapLabel: "color: #7fdbca;",
    observableLabel: "color: #7fdbca;",
    promiseLabel: "color: #7fdbca;",
    generatorLabel: "color: #7fdbca;",
    blobLabel: "color: #7fdbca;",
    unknownLabel: "color: #7fdbca;"
  },
  /**
   * Following is the list of defined variables
    --pre-bg-color
    --pre-fg-color
    --toggle-fg-color
    --braces-fg-color
    --brackets-fg-color
    --dt-number-fg-color
    --dt-bigint-fg-color
    --dt-boolean-fg-color
    --dt-string-fg-color
    --dt-null-fg-color
    --dt-undefined-fg-color
    --prototype-label-fg-color
    --dt-symbol-fg-color
    --dt-regex-fg-color
    --dt-date-fg-color
    --dt-buffer-fg-color
    --function-label-fg-color
    --array-label-fg-color
    --object-label-fg-color
    --map-label-fg-color
    --set-label-fg-color
    --object-key-fg-color
    --object-key-prefix-fg-color
    --class-label-fg-color
    --collpase-label-fg-color
    --getter-label-fg-color
    --circular-label-fg-color
    --weakset-label-fg-color
    --weakref-label-fg-color
    --weakmap-label-fg-color
    --observable-label-fg-color
    --promise-label-fg-color
    --generator-label-fg-color
    --blob-label-fg-color
    --unknown-label-fg-color
   */
  cssVariables: {
    pre: "background-color: var(--pre-bg-color); color: var(--pre-fg-color);",
    toggle: "color: var(--toggle-fg-color); background: none; border: none;",
    braces: "color: var(--braces-fg-color);",
    brackets: "color: var(--brackets-fg-color);",
    number: "color: var(--dt-number-fg-color);",
    bigInt: "color: var(--dt-bigint-fg-color); font-weight: bold;",
    boolean: "color: var(--dt-boolean-fg-color); font-style: italic;",
    string: "color: var(--dt-string-fg-color);",
    null: "color: var(--dt-null-fg-color);",
    undefined: "color: var(--dt-undefined-fg-color);",
    prototypeLabel: "color: var(--prototype-label-fg-color);",
    symbol: "color: var(--dt-symbol-fg-color);",
    regex: "color: var(--dt-regex-fg-color);",
    date: "color: var(--dt-date-fg-color);",
    buffer: "color: var(--dt-buffer-fg-color);",
    functionLabel: "color: var(--function-label-fg-color);",
    arrayLabel: "color: var(--array-label-fg-color);",
    objectLabel: "color: var(--object-label-fg-color);",
    mapLabel: "color: var(--map-label-fg-color);",
    setLabel: "color: var(--set-label-fg-color);",
    objectKey: "color: var(--object-key-fg-color);",
    objectKeyPrefix: "color: var(--object-key-prefix-fg-color); font-style: italic; font-weight: bold",
    classLabel: "color: var(--class-label-fg-color);",
    collapseLabel: "color: var(--collpase-label-fg-color); font-style: italic;",
    getterLabel: "color: var(--getter-label-fg-color);",
    circularLabel: "color: var(--circular-label-fg-color);",
    weakSetLabel: "color: var(--weakset-label-fg-color);",
    weakRefLabel: "color: var(--weakref-label-fg-color);",
    weakMapLabel: "color: var(--weakmap-label-fg-color);",
    observableLabel: "color: var(--observable-label-fg-color);",
    promiseLabel: "color: var(--promise-label-fg-color);",
    generatorLabel: "color: var(--generator-label-fg-color);",
    blobLabel: "color: var(--blob-label-fg-color);",
    unknownLabel: "color: var(--unknown-label-fg-color);"
  }
};

// formatters/html/printers/main.ts
var dropdownIcon = "&#9660;";
function openingBrace$1(formatter) {
  return `<span style="${formatter.styles.braces}">{</span>`;
}
function closingBrace$1(formatter) {
  return `<span style="${formatter.styles.braces}">}</span>`;
}
function openingBrackets$1(formatter) {
  return `<span style="${formatter.styles.brackets}">[</span>`;
}
function closingBrackets$1(formatter) {
  return `<span style="${formatter.styles.brackets}">]</span>`;
}
var HTMLPrinters = {
  "collapse": (token, formatter) => {
    const styles = token.token.type === "object-start" ? formatter.styles.objectLabel : formatter.styles.arrayLabel;
    const collpaseStyles = formatter.styles.collapseLabel;
    return `<span style="${styles}">${token.name}</span> ` + (token.token.type === "object-start" ? openingBrace$1(formatter) : openingBrackets$1(formatter)) + ` <span style="${collpaseStyles}">collapsed</span> ` + (token.token.type === "object-start" ? closingBrace$1(formatter) : closingBrackets$1(formatter));
  },
  "object-start": (token, formatter) => {
    formatter.indentation.increment();
    const styles = formatter.styles.objectLabel;
    const toggleStyles = formatter.styles.toggle;
    const label = formatter.context.isStaticMember && formatter.context.staticDepth === 0 ? " " : `${token.constructorName || "Object [null]"} `;
    return `<span class="dumper-group dumper-object-group"><span style="${styles}">${label}</span>` + openingBrace$1(formatter) + `<button class="dumper-toggle" style="${toggleStyles}"><span>${dropdownIcon}</span></button><samp hidden="true">`;
  },
  "object-end": (_, formatter) => {
    formatter.indentation.decrement();
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + "</samp>" + closingBrace$1(formatter) + "</span>";
  },
  "object-key": (token, formatter) => {
    formatter.context.isStack = token.value === "stack";
    const styles = formatter.styles.objectKey;
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    let value = token.value;
    if (token.isSymbol) {
      value = `[${value}]`;
    } else if (!/^[a-z$_][$\w]*$/i.test(value)) {
      value = `"${htmlEscape(value.replace(/"/g, '\\"'))}"`;
    }
    let prefix = "";
    if (formatter.context.isStaticMember) {
      formatter.context.staticDepth++;
      if (formatter.context.staticDepth === 1) {
        const prefixStyles = formatter.styles.objectKeyPrefix;
        prefix = `<span class="dumper-object-prefix" style="${prefixStyles}">static </span>`;
      }
    }
    return indent + prefix + `<span class="dumper-object-key" style="${styles}">${value}</span>: `;
  },
  "object-circular-ref": (_, formatter) => {
    const styles = formatter.styles.circularLabel;
    return `<span style="${styles}">[*Circular]</span>`;
  },
  "object-max-depth-ref": (_, formatter) => {
    const styles = formatter.styles.objectLabel;
    return `<span style="${styles}">[Object]</span>`;
  },
  "object-value-getter": (_, formatter) => {
    const styles = formatter.styles.getterLabel;
    return `<span style="${styles}">[Getter]</span>`;
  },
  "object-value-start": () => {
    return "";
  },
  "object-value-end": (_, formatter) => {
    if (formatter.context.isStaticMember) {
      formatter.context.staticDepth--;
    }
    return `,`;
  },
  "array-start": (token, formatter) => {
    formatter.indentation.increment();
    const toggleStyles = formatter.styles.toggle;
    const styles = formatter.styles.arrayLabel;
    const label = `${token.name}:${token.size} `;
    return `<span class="dumper-group dumper-array-group"><span style="${styles}">${label}</span>` + openingBrackets$1(formatter) + `<button class="dumper-toggle" style="${toggleStyles}"><span>${dropdownIcon}</span></button><samp hidden="true">`;
  },
  "array-end": (_, formatter) => {
    formatter.indentation.decrement();
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + "</samp>" + closingBrackets$1(formatter) + "</span>";
  },
  "array-value-start": (_, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent;
  },
  "array-value-hole": (_, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    const styles = formatter.styles.undefined;
    return indent + `<span class="dumper-undefined" style="${styles}">${htmlEscape("<hole>")},</span>`;
  },
  "array-value-end": () => {
    return `,`;
  },
  "array-circular-ref": (_, formatter) => {
    const styles = formatter.styles.circularLabel;
    return `<span style="${styles}">[*Circular]</span>`;
  },
  "array-max-depth-ref": (_, formatter) => {
    const styles = formatter.styles.arrayLabel;
    return `<span style="${styles}">[Array]</span>`;
  },
  "array-max-length-ref": (token, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    const styles = formatter.styles.arrayLabel;
    const itemsLeft = token.size - token.limit;
    if (itemsLeft <= 0) {
      return "";
    }
    const label = itemsLeft === 1 ? `1 more item` : `${itemsLeft} more items`;
    return `${indent}<span style="${styles}">[...${label}]</span>`;
  },
  "prototype-start": (_, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    formatter.indentation.increment();
    const styles = formatter.styles.prototypeLabel;
    const toggleStyles = formatter.styles.toggle;
    const label = "[[Prototype]] ";
    return indent + `<span class="dumper-group dumper-prototype-group"><span style="${styles}">${label}</span>` + openingBrace$1(formatter) + `<button class="dumper-toggle" style="${toggleStyles}"><span>${dropdownIcon}</span></button><samp hidden="true">`;
  },
  "prototype-end": (_, formatter) => {
    formatter.indentation.decrement();
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + "</samp>" + closingBrace$1(formatter) + "</span>";
  },
  "map-start": (token, formatter) => {
    formatter.indentation.increment();
    const toggleStyles = formatter.styles.toggle;
    const styles = formatter.styles.mapLabel;
    const label = `Map:${token.size} `;
    return `<span class="dumper-group dumper-map-group"><span style="${styles}">${label}</span>` + openingBrace$1(formatter) + `<button class="dumper-toggle" style="${toggleStyles}"><span>${dropdownIcon}</span></button><samp hidden="true">`;
  },
  "map-end": (_, formatter) => {
    formatter.indentation.decrement();
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + "</samp>" + closingBrace$1(formatter) + "</span>";
  },
  "map-row-start": (_, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    formatter.indentation.increment();
    return indent + openingBrackets$1(formatter);
  },
  "map-row-end": (_, formatter) => {
    formatter.indentation.decrement();
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + closingBrackets$1(formatter) + `,`;
  },
  "map-key-start": (_, formatter) => {
    const styles = formatter.styles.objectKey;
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + `<span style="${styles}">key</span>: `;
  },
  "map-key-end": function() {
    return "";
  },
  "map-value-start": (_, formatter) => {
    const styles = formatter.styles.objectKey;
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + `<span style="${styles}">value</span>: `;
  },
  "map-value-end": function() {
    return "";
  },
  "map-circular-ref": (_, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    const styles = formatter.styles.circularLabel;
    return `${indent}<span style="${styles}">[*Circular]</span>`;
  },
  "map-max-depth-ref": (_, formatter) => {
    const styles = formatter.styles.mapLabel;
    return `<span style="${styles}">[Map]</span>`;
  },
  "map-max-length-ref": (token, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    const styles = formatter.styles.mapLabel;
    const itemsLeft = token.size - token.limit;
    if (itemsLeft <= 0) {
      return "";
    }
    const label = itemsLeft === 1 ? `1 more item` : `${itemsLeft} more items`;
    return `${indent}<span style="${styles}">[...${label}]</span>`;
  },
  "set-start": (token, formatter) => {
    formatter.indentation.increment();
    const toggleStyles = formatter.styles.toggle;
    const styles = formatter.styles.setLabel;
    const label = `Set:${token.size} `;
    return `<span class="dumper-group dumper-set-group"><span class="dumper-set-label" style="${styles}">${label}</span>` + openingBrackets$1(formatter) + `<button class="dumper-toggle" style="${toggleStyles}"><span>${dropdownIcon}</span></button><samp hidden="true">`;
  },
  "set-end": (_, formatter) => {
    formatter.indentation.decrement();
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + "</samp>" + closingBrackets$1(formatter) + "</span>";
  },
  "set-value-start": (_, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent;
  },
  "set-value-end": () => {
    return `,`;
  },
  "set-circular-ref": (_, formatter) => {
    const styles = formatter.styles.circularLabel;
    return `<span style="${styles}">[*Circular]</span>`;
  },
  "set-max-depth-ref": (_, formatter) => {
    const styles = formatter.styles.setLabel;
    return `<span style="${styles}">[Set]</span>`;
  },
  "set-max-length-ref": (token, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    const styles = formatter.styles.setLabel;
    const itemsLeft = token.size - token.limit;
    if (itemsLeft <= 0) {
      return "";
    }
    const label = itemsLeft === 1 ? `1 more item` : `${itemsLeft} more items`;
    return `${indent}<span style="${styles}">[...${label}]</span>`;
  },
  "string": (token, formatter) => {
    let value = token.value;
    const indent = formatter.indentation.getSpaces();
    if (formatter.context.isStack) {
      value = token.value.split("\n").map((row, index) => {
        let rowValue = `<span>${htmlEscape(row.trim())}</span>`;
        if (index > 0) {
          rowValue = `${indent}${rowValue}`;
        }
        return rowValue;
      }).join("\n");
    } else {
      value = wordWrap(token.value, {
        newLine: formatter.newLine,
        indent: formatter.indentation.getSpaces(),
        width: 70
      });
    }
    const styles = formatter.styles.string;
    return `<span class="dumper-string" style="${styles}">${value}</span>`;
  },
  "boolean": (token, formatter) => {
    const styles = formatter.styles.boolean;
    return `<span class="dumper-boolean" style="${styles}">` + token.value + "</span>";
  },
  "number": (token, formatter) => {
    const styles = formatter.styles.number;
    return `<span class="dumper-number" style="${styles}">` + token.value + "</span>";
  },
  "bigInt": (token, formatter) => {
    const styles = formatter.styles.bigInt;
    return `<span class="dumper-big-int" style="${styles}">` + token.value + "</span>";
  },
  "undefined": (_, formatter) => {
    const styles = formatter.styles.undefined;
    return `<span class="dumper-undefined" style="${styles}">undefined</span>`;
  },
  "null": (_, formatter) => {
    const styles = formatter.styles.null;
    return `<span class="dumper-null" style="${styles}">null</span>`;
  },
  "symbol": (token, formatter) => {
    const styles = formatter.styles.symbol;
    return `<span class="dumper-symbol" style="${styles}">` + token.value + "</span>";
  },
  "function": (token, formatter) => {
    const className = token.isClass ? "dumper-class" : "dumper-function";
    const styles = token.isClass ? formatter.styles.classLabel : formatter.styles.functionLabel;
    const async = token.isAsync ? `async ` : "";
    const generator = token.isGenerator ? `*` : "";
    const label = token.isClass ? `[class ${token.name}]` : `[${async}${generator}function ${token.name}]`;
    return `<span class="${className}" style="${styles}">` + label + "</span>";
  },
  "date": function(token, formatter) {
    const styles = formatter.styles.date;
    return `<span class="dumper-date" style="${styles}">` + token.value + "</span>";
  },
  "buffer": function(token, formatter) {
    const styles = formatter.styles.buffer;
    return `<span class="dumper-buffer" style="${styles}">` + htmlEscape(token.value) + "</span>";
  },
  "regexp": function(token, formatter) {
    const styles = formatter.styles.regex;
    return `<span class="dumper-regex" style="${styles}">` + token.value + "</span>";
  },
  "unknown": function(token, formatter) {
    const styles = formatter.styles.unknownLabel;
    return `<span class="dumper-value-unknown" style="${styles}">` + String(token.value) + "</span>";
  },
  "weak-set": function(_, formatter) {
    const styles = formatter.styles.weakSetLabel;
    return `<span class="dumper-weak-set" style="${styles}">[WeakSet]</span>`;
  },
  "weak-ref": function(_, formatter) {
    const styles = formatter.styles.weakRefLabel;
    return `<span class="dumper-weak-ref" style="${styles}">[WeakRef]</span>`;
  },
  "weak-map": function(_, formatter) {
    const styles = formatter.styles.weakMapLabel;
    return `<span class="dumper-weak-map" style="${styles}">[WeakMap]</span>`;
  },
  "observable": function(_, formatter) {
    const styles = formatter.styles.observableLabel;
    return `<span class="dumper-observable" style="${styles}">[Observable]</span>`;
  },
  "blob": function(token, formatter) {
    const styles = formatter.styles.objectLabel;
    const propertiesStart = `<span styles="${formatter.styles.braces}">{ `;
    const propertiesEnd = `<span styles="${formatter.styles.braces}"> }</span></span>`;
    const sizeProp = `<span styles="${formatter.styles.objectKey}">size: </span>`;
    const sizeValue = `<span styles="${formatter.styles.number}">${token.size}</span>,`;
    const typeProp = `<span styles="${formatter.styles.objectKey}">type: </span>`;
    const typeValue = `<span styles="${formatter.styles.string}">${token.contentType}</span>`;
    return `<span class="dumper-blob" style="${styles}">[Blob]` + propertiesStart + `${sizeProp}${sizeValue} ${typeProp}${typeValue}` + propertiesEnd + "</span>";
  },
  "promise": function(token, formatter) {
    const styles = formatter.styles.promiseLabel;
    const label = token.isFulfilled ? "resolved" : "pending";
    return `<span class="dumper-promise" style="${styles}">[Promise${htmlEscape(`<${label}>`)}]</span>`;
  },
  "generator": function(token, formatter) {
    const styles = formatter.styles.generatorLabel;
    const label = token.isAsync ? "[AsyncGenerator] {}" : "[Generator] {}";
    return `<span class="dumper-generator" style="${styles}">` + label + "</span>";
  },
  "static-members-start": function(_, formatter) {
    formatter.context.isStaticMember = true;
    formatter.context.staticDepth = 0;
    return "";
  },
  "static-members-end": function(_, formatter) {
    formatter.context.isStaticMember = false;
    formatter.context.staticDepth = 0;
    return "";
  }
};

// formatters/html/formatter.ts
var seed = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var nanoid = (length = 15) => {
  let output = "";
  let random = new Uint8Array(length);
  if (globalThis.crypto) {
    crypto.getRandomValues(random);
  } else {
    for (let i = 0; i < length; i++) {
      random[i] = Math.floor(Math.random() * 256);
    }
  }
  for (let n = 0; n < length; n++) {
    output += seed[63 & random[n]];
  }
  return output;
};
var HTMLFormatter = class {
  #config;
  /**
   * Styles for output elements
   */
  styles;
  /**
   * Context maintained through out the printing
   * phase. Each instance has its own context
   * that gets mutated internally.
   */
  context;
  /**
   * Value for the newline character
   */
  newLine = "\n";
  /**
   * Utility to manage indentation
   */
  indentation = {
    counter: 0,
    /**
     * Increment the identation by 1 step
     */
    increment() {
      this.counter++;
    },
    /**
     * Decrement the identation by 1 step
     */
    decrement() {
      this.counter--;
    },
    /**
     * Get the identation spaces as per the current
     * identation level
     */
    getSpaces() {
      return new Array(this.counter * 2 + 1).join("&nbsp;");
    }
  };
  constructor(config, context) {
    this.context = context || {};
    this.#config = config || {};
    this.styles = Object.freeze({ ...themes$1.nightOwl, ...config?.styles });
  }
  /**
   * Wraps the final output inside pre tags and add the script
   * to activate the frontend iteractions.
   */
  #wrapOutput(code) {
    const id = `dump-${nanoid()}`;
    const expand = this.#config.expand === "all" ? `'all'` : this.#config.expand;
    const nonce = this.#config.cspNonce ? ` nonce="${this.#config.cspNonce}"` : "";
    return `<div id="${id}" class="dumper-dump"><pre style="${this.styles.pre}"><code>${code}</code></pre><script${nonce}>dumperActivate('${id}', ${expand})</script></div>`;
  }
  /**
   * Format a collection of tokens to HTML output wrapped
   * inside the `pre` tag.
   */
  format(tokens) {
    return this.#wrapOutput(
      tokens.map((token) => {
        const formatter = HTMLPrinters[token.type];
        return formatter(token, this) || "";
      }).join("")
    );
  }
};

// formatters/html/head.ts
function createStyleSheet() {
  return `.dumper-dump, .dumper-dump pre, .dumper-dump code, .dumper-dump samp {
  font-family: JetBrains Mono, monaspace argon, Menlo, Monaco, Consolas, monospace;
}
.dumper-dump pre {
  line-height: 24px;
  font-size: 15px;
  overflow-x: scroll;
  position:relative;
  z-index:99999;
  padding: 10px 15px;
  margin: 0;
}
.dumper-dump pre samp {
  position: relative;
}
.dumper-dump pre samp[hidden="true"] {
  display: none;
}
.dumper-dump .dumper-prototype-group {
  opacity: 0.5;
}

.dumper-dump .dumper-toggle {
   transform: rotate(270deg);
}

.dumper-dump .dumper-toggle span {
  display: inline-block;
  position: relative;
  top: 1px;
  margin: 0 5px;
  font-size: 14px;
}
.dumper-dump .dumper-toggle[aria-expanded="true"] {
  transform: none;
}`;
}
function createScript() {
  return `function expandGroup(group) {
  const trigger = group.querySelector('button')
  trigger.setAttribute('aria-expanded', 'true')

  const samp = group.querySelector('samp')
  samp.removeAttribute('hidden')
}

function collapseGroup(group) {
  const trigger = group.querySelector('button')
  trigger.removeAttribute('aria-expanded', 'true')

  const samp = group.querySelector('samp')
  samp.setAttribute('hidden', 'true')
}

function dumperActivate(dumpId, expand) {
  if (expand === true) {
    expandGroup(document.querySelector(\`#\${dumpId} .dumper-group\`))
  } else if (expand === 'all') {
    document.querySelectorAll(\`#\${dumpId} .dumper-group\`).forEach((c) => expandGroup(c))
  }

  document.querySelectorAll(\`#\${dumpId} .dumper-toggle\`).forEach((trigger) => {
    trigger.addEventListener('click', function (event) {
      const target = event.currentTarget
      const parent = target.parentElement
      const isExpanded = !!target.getAttribute('aria-expanded')

      if (isExpanded) {
        collapseGroup(parent)
        if (event.metaKey) {
          parent.querySelectorAll('.dumper-group').forEach((c) => collapseGroup(c))
        }
      } else {
        expandGroup(parent)
        if (event.metaKey) {
          parent.querySelectorAll('.dumper-group').forEach((c) => expandGroup(c))
        }
      }
    })
  })
}`;
}

// formatters/html/main.ts
function dump$1(value, config) {
  const parser = new Parser(config);
  parser.parse(value);
  return new HTMLFormatter(config).format(parser.flush());
}

// From: https://github.com/sindresorhus/has-flag/blob/main/index.js
/// function hasFlag(flag, argv = globalThis.Deno?.args ?? process.argv) {
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process$1.argv) {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}

const {env} = process$1;

let flagForceColor;
if (
	hasFlag('no-color')
	|| hasFlag('no-colors')
	|| hasFlag('color=false')
	|| hasFlag('color=never')
) {
	flagForceColor = 0;
} else if (
	hasFlag('color')
	|| hasFlag('colors')
	|| hasFlag('color=true')
	|| hasFlag('color=always')
) {
	flagForceColor = 1;
}

function envForceColor() {
	if (!('FORCE_COLOR' in env)) {
		return;
	}

	if (env.FORCE_COLOR === 'true') {
		return 1;
	}

	if (env.FORCE_COLOR === 'false') {
		return 0;
	}

	if (env.FORCE_COLOR.length === 0) {
		return 1;
	}

	const level = Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);

	if (![0, 1, 2, 3].includes(level)) {
		return;
	}

	return level;
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3,
	};
}

function _supportsColor(haveStream, {streamIsTTY, sniffFlags = true} = {}) {
	const noFlagForceColor = envForceColor();
	if (noFlagForceColor !== undefined) {
		flagForceColor = noFlagForceColor;
	}

	const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;

	if (forceColor === 0) {
		return 0;
	}

	if (sniffFlags) {
		if (hasFlag('color=16m')
			|| hasFlag('color=full')
			|| hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}
	}

	// Check for Azure DevOps pipelines.
	// Has to be above the `!streamIsTTY` check.
	if ('TF_BUILD' in env && 'AGENT_NAME' in env) {
		return 1;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process$1.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10
			&& Number(osRelease[2]) >= 10_586
		) {
			return Number(osRelease[2]) >= 14_931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['GITHUB_ACTIONS', 'GITEA_ACTIONS', 'CIRCLECI'].some(key => key in env)) {
			return 3;
		}

		if (['TRAVIS', 'APPVEYOR', 'GITLAB_CI', 'BUILDKITE', 'DRONE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if (env.TERM === 'xterm-kitty') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app': {
				return version >= 3 ? 3 : 2;
			}

			case 'Apple_Terminal': {
				return 2;
			}
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function createSupportsColor(stream, options = {}) {
	const level = _supportsColor(stream, {
		streamIsTTY: stream && stream.isTTY,
		...options,
	});

	return translateLevel(level);
}

const supportsColor = {
	stdout: createSupportsColor({isTTY: tty__default.isatty(1)}),
	stderr: createSupportsColor({isTTY: tty__default.isatty(2)}),
};

var colors = supportsColor.stdout ? index_default.ansi() : index_default.silent();
var themes = {
  default: {
    braces: (value) => colors.yellow(value),
    brackets: (value) => colors.yellow(value),
    number: (value) => colors.yellow(value),
    bigInt: (value) => colors.yellow().bold(value),
    boolean: (value) => colors.yellow().italic(value),
    string: (value) => colors.green(value),
    null: (value) => colors.dim(value),
    undefined: (value) => colors.dim(value),
    prototypeLabel: (value) => colors.dim(value),
    symbol: (value) => colors.magenta(value),
    regex: (value) => colors.red(value),
    date: (value) => colors.magenta(value),
    buffer: (value) => colors.magenta(value),
    functionLabel: (value) => colors.cyan().italic(value),
    arrayLabel: (value) => colors.cyan(value),
    objectLabel: (value) => colors.cyan(value),
    mapLabel: (value) => colors.cyan(value),
    setLabel: (value) => colors.cyan(value),
    objectKey: (value) => colors.blue(value),
    objectKeyPrefix: (value) => colors.dim(value),
    classLabel: (value) => colors.cyan(value),
    weakSetLabel: (value) => colors.cyan(value),
    weakRefLabel: (value) => colors.cyan(value),
    collapseLabel: (value) => colors.dim(value),
    circularLabel: (value) => colors.cyan(value),
    getterLabel: (value) => colors.cyan(value),
    weakMapLabel: (value) => colors.cyan(value),
    observableLabel: (value) => colors.cyan(value),
    promiseLabel: (value) => colors.blue(value),
    generatorLabel: (value) => colors.cyan(value),
    blobLabel: (value) => colors.magenta(value),
    unknownLabel: (value) => colors.magenta(value)
  }
};

// formatters/console/printers/main.ts
function openingBrace(formatter) {
  return formatter.styles.braces("{");
}
function closingBrace(formatter) {
  return formatter.styles.braces("}");
}
function openingBrackets(formatter) {
  return formatter.styles.brackets("[");
}
function closingBrackets(formatter) {
  return formatter.styles.brackets("]");
}
var ConsolePrinters = {
  "collapse": (token, formatter) => {
    const styles = token.token.type === "object-start" ? formatter.styles.objectLabel : formatter.styles.arrayLabel;
    const collpaseStyles = formatter.styles.collapseLabel;
    return `${styles(token.name)} ` + (token.token.type === "object-start" ? openingBrace(formatter) : openingBrackets(formatter)) + ` ${collpaseStyles("collpased")} ` + (token.token.type === "object-start" ? closingBrace(formatter) : closingBrackets(formatter));
  },
  "object-start": (token, formatter) => {
    formatter.indentation.increment();
    const styles = formatter.styles.objectLabel;
    const label = formatter.context.isStaticMember && formatter.context.staticDepth === 0 || token.constructorName === "Object" ? "" : styles(`${token.constructorName || "Object [null]"}`) + " ";
    return label + openingBrace(formatter);
  },
  "object-end": (_, formatter) => {
    formatter.indentation.decrement();
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + closingBrace(formatter);
  },
  "object-key": (token, formatter) => {
    formatter.context.isStack = token.value === "stack";
    const styles = formatter.styles.objectKey;
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    let value = token.value;
    if (token.isSymbol) {
      value = `[${value}]`;
    }
    let prefix = "";
    if (formatter.context.isStaticMember) {
      formatter.context.staticDepth++;
      if (formatter.context.staticDepth === 1) {
        const prefixStyles = formatter.styles.objectKeyPrefix;
        prefix = `${prefixStyles("static")} `;
      }
    }
    return indent + prefix + styles(value) + ": ";
  },
  "object-circular-ref": (_, formatter) => {
    const styles = formatter.styles.circularLabel;
    return styles("[*Circular]");
  },
  "object-max-depth-ref": (_, formatter) => {
    const styles = formatter.styles.objectLabel;
    return styles("[Object]");
  },
  "object-value-getter": (_, formatter) => {
    const styles = formatter.styles.getterLabel;
    return styles("[Getter]");
  },
  "object-value-start": () => {
    return "";
  },
  "object-value-end": (_, formatter) => {
    if (formatter.context.isStaticMember) {
      formatter.context.staticDepth--;
    }
    return `,`;
  },
  "array-start": (token, formatter) => {
    formatter.indentation.increment();
    const styles = formatter.styles.arrayLabel;
    const label = token.name !== "Array" ? styles(`${token.name}`) + " " : "";
    return label + openingBrackets(formatter);
  },
  "array-end": (_, formatter) => {
    formatter.indentation.decrement();
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + closingBrackets(formatter);
  },
  "array-value-start": (_, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent;
  },
  "array-value-hole": (_, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    const styles = formatter.styles.undefined;
    return indent + styles("<hole>") + ",";
  },
  "array-value-end": () => {
    return `,`;
  },
  "array-circular-ref": (_, formatter) => {
    const styles = formatter.styles.circularLabel;
    return styles("[*Circular]");
  },
  "array-max-depth-ref": (_, formatter) => {
    const styles = formatter.styles.arrayLabel;
    return styles("[Array]");
  },
  "array-max-length-ref": (token, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    const styles = formatter.styles.arrayLabel;
    const itemsLeft = token.size - token.limit;
    if (itemsLeft <= 0) {
      return "";
    }
    const label = itemsLeft === 1 ? `1 more item` : `${itemsLeft} more items`;
    return indent + styles(`[...${label}]`);
  },
  "prototype-start": (_, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    formatter.indentation.increment();
    const styles = formatter.styles.prototypeLabel;
    const label = "[[Prototype]] ";
    return indent + styles(label) + openingBrace(formatter);
  },
  "prototype-end": (_, formatter) => {
    formatter.indentation.decrement();
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + closingBrace(formatter);
  },
  "map-start": (token, formatter) => {
    formatter.indentation.increment();
    const styles = formatter.styles.mapLabel;
    const label = `Map(${token.size}) `;
    return styles(label) + openingBrace(formatter);
  },
  "map-end": (_, formatter) => {
    formatter.indentation.decrement();
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + closingBrace(formatter);
  },
  "map-row-start": (_, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    formatter.indentation.increment();
    return indent + openingBrackets(formatter);
  },
  "map-row-end": (_, formatter) => {
    formatter.indentation.decrement();
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + closingBrackets(formatter) + `,`;
  },
  "map-key-start": (_, formatter) => {
    const styles = formatter.styles.objectKey;
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + styles("key") + ": ";
  },
  "map-key-end": function() {
    return ",";
  },
  "map-value-start": (_, formatter) => {
    const styles = formatter.styles.objectKey;
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + styles("value") + ": ";
  },
  "map-value-end": function() {
    return ",";
  },
  "map-circular-ref": (_, formatter) => {
    const styles = formatter.styles.circularLabel;
    return styles("[*Circular]");
  },
  "map-max-depth-ref": (_, formatter) => {
    const styles = formatter.styles.mapLabel;
    return styles("[Map]");
  },
  "map-max-length-ref": (token, formatter) => {
    const styles = formatter.styles.mapLabel;
    const itemsLeft = token.size - token.limit;
    if (itemsLeft <= 0) {
      return "";
    }
    const label = itemsLeft === 1 ? `1 more item` : `${itemsLeft} more items`;
    return styles(`[...${label}]`);
  },
  "set-start": (token, formatter) => {
    formatter.indentation.increment();
    const styles = formatter.styles.setLabel;
    const label = `Set(${token.size}) `;
    return styles(label) + openingBrackets(formatter);
  },
  "set-end": (_, formatter) => {
    formatter.indentation.decrement();
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent + closingBrackets(formatter);
  },
  "set-value-start": (_, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    return indent;
  },
  "set-value-end": () => {
    return `,`;
  },
  "set-circular-ref": (_, formatter) => {
    const styles = formatter.styles.circularLabel;
    return styles("[*Circular]");
  },
  "set-max-depth-ref": (_, formatter) => {
    const styles = formatter.styles.setLabel;
    return styles("[Set]");
  },
  "set-max-length-ref": (token, formatter) => {
    const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
    const styles = formatter.styles.setLabel;
    const itemsLeft = token.size - token.limit;
    if (itemsLeft <= 0) {
      return "";
    }
    const label = itemsLeft === 1 ? `1 more item` : `${itemsLeft} more items`;
    return indent + styles(`[...${label}]`);
  },
  "string": (token, formatter) => {
    let value = token.value;
    const indent = formatter.indentation.getSpaces();
    if (formatter.context.isStack) {
      value = token.value.split("\n").map((row, index) => {
        let rowValue = row.trim();
        if (index > 0) {
          rowValue = `${indent}${rowValue}`;
        }
        return rowValue;
      }).join("\n");
    } else {
      value = wordWrap(token.value, {
        newLine: formatter.newLine,
        indent: formatter.indentation.getSpaces(),
        width: 70,
        escape: (line) => line
      });
    }
    const styles = formatter.styles.string;
    return styles(value);
  },
  "boolean": (token, formatter) => {
    const styles = formatter.styles.boolean;
    return styles(String(token.value));
  },
  "number": (token, formatter) => {
    const styles = formatter.styles.number;
    return styles(String(token.value));
  },
  "bigInt": (token, formatter) => {
    const styles = formatter.styles.bigInt;
    return styles(token.value);
  },
  "undefined": (_, formatter) => {
    const styles = formatter.styles.undefined;
    return styles("undefined");
  },
  "null": (_, formatter) => {
    const styles = formatter.styles.null;
    return styles("null");
  },
  "symbol": (token, formatter) => {
    const styles = formatter.styles.symbol;
    return styles(token.value);
  },
  "function": (token, formatter) => {
    const styles = token.isClass ? formatter.styles.classLabel : formatter.styles.functionLabel;
    const async = token.isAsync ? `async ` : "";
    const generator = token.isGenerator ? `*` : "";
    const label = token.isClass ? `[class ${token.name}]` : `[${async}${generator}function ${token.name}]`;
    return styles(label);
  },
  "date": function(token, formatter) {
    const styles = formatter.styles.date;
    return styles(token.value);
  },
  "buffer": function(token, formatter) {
    const styles = formatter.styles.buffer;
    return styles(token.value);
  },
  "regexp": function(token, formatter) {
    const styles = formatter.styles.regex;
    return styles(token.value);
  },
  "unknown": function(token, formatter) {
    const styles = formatter.styles.unknownLabel;
    return styles(String(token.value));
  },
  "weak-set": function(_, formatter) {
    const styles = formatter.styles.weakSetLabel;
    return styles("[WeakSet]");
  },
  "weak-ref": function(_, formatter) {
    const styles = formatter.styles.weakRefLabel;
    return styles("[WeakRef]");
  },
  "weak-map": function(_, formatter) {
    const styles = formatter.styles.weakMapLabel;
    return styles("[WeakMap]");
  },
  "observable": function(_, formatter) {
    const styles = formatter.styles.observableLabel;
    return styles("[Observable]");
  },
  "blob": function(token, formatter) {
    const styles = formatter.styles.objectLabel;
    const sizeProp = formatter.styles.objectKey("size: ");
    const sizeValue = formatter.styles.number(`${token.size}`);
    const typeProp = token.contentType ? `, ${formatter.styles.objectKey("type: ")}` : "";
    const typeValue = token.contentType ? formatter.styles.string(`${token.contentType}`) : "";
    return styles("[Blob]") + " " + openingBrace(formatter) + `${sizeProp}${sizeValue}${typeProp}${typeValue}` + closingBrace(formatter);
  },
  "promise": function(token, formatter) {
    const styles = formatter.styles.promiseLabel;
    const label = token.isFulfilled ? "resolved" : "pending";
    return styles(`[Promise${`<${label}>`}]`);
  },
  "generator": function(token, formatter) {
    const styles = formatter.styles.generatorLabel;
    const label = token.isAsync ? "[AsyncGenerator] {}" : "[Generator] {}";
    return styles(label);
  },
  "static-members-start": function(_, formatter) {
    formatter.context.isStaticMember = true;
    formatter.context.staticDepth = 0;
    return " ";
  },
  "static-members-end": function(_, formatter) {
    formatter.context.isStaticMember = false;
    formatter.context.staticDepth = 0;
    return "";
  }
};

// formatters/console/formatter.ts
var ConsoleFormatter = class {
  /**
   * Styles for output elements
   */
  styles;
  /**
   * Context maintained through out the printing
   * phase. Each instance has its own context
   * that gets mutated internally.
   */
  context;
  /**
   * Value for the newline character
   */
  newLine = "\n";
  /**
   * Utility to manage indentation
   */
  indentation = {
    counter: 0,
    /**
     * Increment the identation by 1 step
     */
    increment() {
      this.counter++;
    },
    /**
     * Decrement the identation by 1 step
     */
    decrement() {
      this.counter--;
    },
    /**
     * Get the identation spaces as per the current
     * identation level
     */
    getSpaces() {
      return new Array(this.counter * 2 + 1).join(" ");
    }
  };
  constructor(config, context) {
    this.context = context || {};
    this.styles = Object.freeze({ ...themes.default, ...config?.styles });
  }
  /**
   * Format a collection of tokens to ANSI output
   */
  format(tokens) {
    return tokens.map((token) => {
      const formatter = ConsolePrinters[token.type];
      return formatter(token, this) || "";
    }).join("");
  }
};

// formatters/console/main.ts
function dump(value, config) {
  const parser = new Parser(config);
  parser.parse(value);
  return new ConsoleFormatter(config).format(parser.flush());
}

var ErrorCause = class extends BaseComponent {
  cssFile = new URL("./error_cause/style.css", publicDirURL);
  /**
   * The toHTML method is used to output the HTML for the
   * web view
   */
  async toHTML(props) {
    if (!props.error.cause) {
      return "";
    }
    return `<section>
      <div class="card">
        <div class="card-heading">
          <div>
            <h3 class="card-title">
              Error Cause
            </h3>
          </div>
        </div>
        <div class="card-body">
          <div id="error-cause">
            ${dump$1(props.error.cause, {
      cspNonce: props.cspNonce,
      styles: themes$1.cssVariables,
      inspectObjectPrototype: false,
      inspectStaticMembers: false,
      inspectArrayPrototype: false
    })}
          </div>
        </div>
      </div>
    </section>`;
  }
  /**
   * The toANSI method is used to output the text for the console
   */
  async toANSI(props) {
    if (!props.error.cause) {
      return "";
    }
    let depth = process.env.YOUCH_CAUSE ? Number(process.env.YOUCH_CAUSE) : 2;
    if (Number.isNaN(depth)) {
      depth = 2;
    }
    return `

${colors$1.red("[CAUSE]")}
${dump(props.error.cause, {
      depth,
      inspectObjectPrototype: false,
      inspectStaticMembers: false,
      inspectArrayPrototype: false
    })}`;
  }
};

// src/templates/error_info/main.ts
var ERROR_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" width="24" height="24" fill="none"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 7v6m0 4.01.01-.011M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10Z"/></svg>`;
var HINT_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" width="24" height="24" fill="none"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="m21 2-1 1M3 2l1 1m17 13-1-1M3 16l1-1m5 3h6m-5 3h4M12 3C8 3 5.952 4.95 6 8c.023 1.487.5 2.5 1.5 3.5S9 13 9 15h6c0-2 .5-2.5 1.5-3.5h0c1-1 1.477-2.013 1.5-3.5.048-3.05-2-5-6-5Z"/></svg>`;
var COPY_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"  stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg>`;
function htmlAttributeEscape(value) {
  return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
var ErrorInfo = class extends BaseComponent {
  cssFile = new URL("./error_info/style.css", publicDirURL);
  scriptFile = new URL("./error_info/script.js", publicDirURL);
  /**
   * The toHTML method is used to output the HTML for the
   * web view
   */
  async toHTML(props) {
    return `<section>
      <h4 id="error-name">${props.error.name}</h4>
      <h1 id="error-title">${props.title}</h1>
    </section>
    <section>
      <div class="card">
        <div class="card-body">
          <h2 id="error-message">
            <span>${ERROR_ICON_SVG}</span>
            <span>${props.error.message}</span>
            <button
              id="copy-error-btn"
              data-error-text="${htmlAttributeEscape(`${props.error.name}: ${props.error.message}`)}"
              onclick="copyErrorMessage(this)"
              title="Copy error message"
              aria-label="Copy error message to clipboard"
            >
              ${COPY_ICON_SVG}
            </button>
          </h2>
          ${props.error.hint ? `<div id="error-hint">
                <span>${HINT_ICON_SVG}</span>
                <span>${props.error.hint}</span>
              </div>` : ""}
        </div>
      </div>
    </section>`;
  }
  /**
   * The toANSI method is used to output the text for the console
   */
  async toANSI(props) {
    const errorMessage = colors$1.red(
      `\u2139 ${wordWrap$1(`${props.error.name}: ${props.error.message}`, {
        width: process.stdout.columns,
        indent: "  ",
        newLine: "\n",
        escape: (value) => value
      })}`
    );
    const hint = props.error.hint ? `

${colors$1.blue("\u25C9")} ${colors$1.dim().italic(
      wordWrap$1(props.error.hint.replace(/(<([^>]+)>)/gi, ""), {
        width: process.stdout.columns,
        indent: "  ",
        newLine: "\n",
        escape: (value) => value
      })
    )}` : "";
    return `${errorMessage}${hint}`;
  }
};

var ErrorMetadata = class extends BaseComponent {
  #primitives = ["string", "boolean", "number", "undefined"];
  /**
   * Formats the error row value
   */
  #formatRowValue(value, dumpValue, cspNonce) {
    if (dumpValue === true) {
      return dump$1(value, { styles: themes$1.cssVariables, cspNonce });
    }
    if (this.#primitives.includes(typeof value) || value === null) {
      return value;
    }
    return dump$1(value, { styles: themes$1.cssVariables, cspNonce });
  }
  /**
   * Returns HTML fragment with HTML table containing rows
   * metadata section rows
   */
  #renderRows(rows, cspNonce) {
    return `<table class="card-table">
      <tbody>
        ${rows.map((row) => {
      return `<tr>
              <td class="table-key">${row.key}</td>
              <td class="table-value">
                ${this.#formatRowValue(row.value, row.dump, cspNonce)}
              </td>
            </tr>`;
    }).join("\n")}
      </tbody>
    </table>`;
  }
  /**
   * Renders each section with its rows inside a table
   */
  #renderSection(section, rows, cspNonce) {
    return `<div>
      <h4 class="card-subtitle">${section}</h4>
      ${Array.isArray(rows) ? this.#renderRows(rows, cspNonce) : `<span>${this.#formatRowValue(rows.value, rows.dump, cspNonce)}</span>`}
    </div>`;
  }
  /**
   * Renders each group as a card
   */
  #renderGroup(group, sections, cspNonce) {
    return `<section>
      <div class="card">
        <div class="card-heading">
          <h3 class="card-title">${group}</h3>
        </div>
        <div class="card-body">
          ${Object.keys(sections).map((section) => this.#renderSection(section, sections[section], cspNonce)).join("\n")}
        </div>
      </div>
    </section>`;
  }
  /**
   * The toHTML method is used to output the HTML for the
   * web view
   */
  async toHTML(props) {
    const groups = props.metadata.toJSON();
    const groupsNames = Object.keys(groups);
    if (!groupsNames.length) {
      return "";
    }
    return groupsNames.map((group) => this.#renderGroup(group, groups[group], props.cspNonce)).join("\n");
  }
  /**
   * The toANSI method is used to output the text for the console
   */
  async toANSI() {
    return "";
  }
};

var CHEVIRON = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" width="24" height="24" stroke-width="2">
  <path d="M6 9l6 6l6 -6"></path>
</svg>`;
var EDITORS = {
  textmate: "txmt://open?url=file://%f&line=%l",
  macvim: "mvim://open?url=file://%f&line=%l",
  emacs: "emacs://open?url=file://%f&line=%l",
  sublime: "subl://open?url=file://%f&line=%l",
  phpstorm: "phpstorm://open?file=%f&line=%l",
  atom: "atom://core/open/file?filename=%f&line=%l",
  vscode: "vscode://file/%f:%l"
};
var ErrorStack = class extends BaseComponent {
  cssFile = new URL("./error_stack/style.css", publicDirURL);
  scriptFile = new URL("./error_stack/script.js", publicDirURL);
  /**
   * Returns the file's relative name from the CWD
   */
  #getRelativeFileName(filePath) {
    return filePath.replace(`${process.cwd()}/`, "");
  }
  /**
   * Returns the index of the frame that should be expanded by
   * default
   */
  #getFirstExpandedFrameIndex(frames) {
    let expandAtIndex = frames.findIndex((frame) => frame.type === "app");
    if (expandAtIndex === -1) {
      expandAtIndex = frames.findIndex((frame) => frame.type === "module");
    }
    return expandAtIndex;
  }
  /**
   * Returns the link to open the file within known code
   * editors
   */
  #getEditorLink(ide, frame) {
    const editorURL = EDITORS[ide] || ide;
    if (!editorURL || frame.type === "native") {
      return {
        text: this.#getRelativeFileName(frame.fileName)
      };
    }
    return {
      href: editorURL.replace("%f", frame.fileName).replace("%l", String(frame.lineNumber)),
      text: this.#getRelativeFileName(frame.fileName)
    };
  }
  /**
   * Returns the HTML fragment for the frame location
   */
  #renderFrameLocation(frame, ide) {
    const { text, href } = this.#getEditorLink(ide, frame);
    const fileName = `<a${href ? ` href="${href}"` : ""} class="stack-frame-filepath" title="${text}">
      ${htmlEscape$1(text)}
    </a>`;
    const functionName = frame.functionName ? `<span>in <code title="${frame.functionName}">
        ${htmlEscape$1(frame.functionName)}
      </code></span>` : "";
    const loc = `<span>at line <code>${frame.lineNumber}:${frame.columnNumber}</code></span>`;
    if (frame.type !== "native" && frame.source) {
      return `<button class="stack-frame-location">
        ${fileName} ${functionName} ${loc}
      </button>`;
    }
    return `<div class="stack-frame-location">
      ${fileName} ${functionName} ${loc}
    </div>`;
  }
  /**
   * Returns HTML fragment for the stack frame
   */
  async #renderStackFrame(frame, index, expandAtIndex, props) {
    const label = frame.type === "app" ? '<span class="frame-label">In App</span>' : "";
    const expandedClass = expandAtIndex === index ? " expanded" : "";
    const toggleButton = frame.type !== "native" && frame.source ? `<button class="stack-frame-toggle-indicator">${CHEVIRON}</button>` : "";
    return `<li class="stack-frame stack-frame-${frame.type}${expandedClass}">
      <div class="stack-frame-contents">
        ${this.#renderFrameLocation(frame, props.ide)}
        <div class="stack-frame-extras">
          ${label}
          ${toggleButton}
        </div>
      </div>
      <div class="stack-frame-source">
        ${await props.sourceCodeRenderer(props.error, frame)}
      </div>
    </li>`;
  }
  /**
   * Returns the ANSI output to print the stack frame on the
   * terminal
   */
  async #printStackFrame(frame, index, expandAtIndex, props) {
    const fileName = this.#getRelativeFileName(frame.fileName);
    const loc = `${fileName}:${frame.lineNumber}:${frame.columnNumber}`;
    if (index === expandAtIndex) {
      const functionName2 = frame.functionName ? `at ${frame.functionName} ` : "";
      const codeSnippet = await props.sourceCodeRenderer(props.error, frame);
      return ` \u2043 ${functionName2}${colors$1.yellow(`(${loc})`)}${codeSnippet}`;
    }
    if (frame.type === "native") {
      const functionName2 = frame.functionName ? `at ${colors$1.italic(frame.functionName)} ` : "";
      return colors$1.dim(` \u2043 ${functionName2}(${colors$1.italic(loc)})`);
    }
    const functionName = frame.functionName ? `at ${frame.functionName} ` : "";
    return ` \u2043 ${functionName}${colors$1.yellow(`(${loc})`)}`;
  }
  /**
   * The toHTML method is used to output the HTML for the
   * web view
   */
  async toHTML(props) {
    const frames = await Promise.all(
      props.error.frames.map((frame, index) => {
        return this.#renderStackFrame(
          frame,
          index,
          this.#getFirstExpandedFrameIndex(props.error.frames),
          props
        );
      })
    );
    return `<section>
      <div class="card">
        <div class="card-heading">
          <div>
            <h3 class="card-title">
              Stack Trace
            </h3>
          </div>
        </div>
        <div class="card-body">
          <div id="stack-frames-wrapper">
            <div id="stack-frames-header">
              <div id="all-frames-toggle-wrapper">
                <label id="all-frames-toggle">
                  <input type="checkbox" />
                  <span> View All Frames </span>
                </label>
              </div>

              <div>
                <div class="toggle-switch">
                  <button id="formatted-frames-toggle" class="active"> Pretty </button>
                  <button id="raw-frames-toggle"> Raw </button>
                </div>
              </div>
            </div>

            <div id="stack-frames-body">
              <div id="stack-frames-formatted" class="visible">
                <ul id="stack-frames">
                  ${frames.join("\n")}
                </ul>
              </div>
              <div id="stack-frames-raw">
                ${dump$1(props.error.raw, {
      styles: themes$1.cssVariables,
      expand: true,
      cspNonce: props.cspNonce,
      inspectObjectPrototype: false,
      inspectStaticMembers: false,
      inspectArrayPrototype: false
    })}
              </div>
            </div>
          <div>
        </div>
      </div>
    </section>`;
  }
  /**
   * The toANSI method is used to output the text for the console
   */
  async toANSI(props) {
    const displayRaw = process.env.YOUCH_RAW;
    if (displayRaw) {
      const depth = Number.isNaN(Number(displayRaw)) ? 2 : Number(displayRaw);
      return `

${colors$1.red("[RAW]")}
${dump(props.error.raw, {
        depth,
        inspectObjectPrototype: false,
        inspectStaticMembers: false,
        inspectArrayPrototype: false
      })}`;
    }
    const frames = await Promise.all(
      props.error.frames.map((frame, index) => {
        return this.#printStackFrame(
          frame,
          index,
          this.#getFirstExpandedFrameIndex(props.error.frames),
          props
        );
      })
    );
    return `

${frames.join("\n")}`;
  }
};

var Xt$1=Object.defineProperty;var w$1=t=>e=>{var s=t[e];if(s)return s();throw new Error("Module not found in bundle: "+e)};var a$1=(t,e)=>()=>(t&&(e=t(t=0)),e);var p=(t,e)=>{for(var s in e)Xt$1(t,s,{get:e[s],enumerable:true});};var P$1={};p(P$1,{default:()=>Wt$1});var Wt$1,F$1=a$1(()=>{Wt$1=[{type:"cmnt",match:/(;|#).*/gm},{expand:"str"},{expand:"num"},{type:"num",match:/\$[\da-fA-F]*\b/g},{type:"kwd",match:/^[a-z]+\s+[a-z.]+\b/gm,sub:[{type:"func",match:/^[a-z]+/g}]},{type:"kwd",match:/^\t*[a-z][a-z\d]*\b/gm},{match:/%|\$/g,type:"oper"}];});var $$1={};p($$1,{default:()=>T});var M$1,T,f=a$1(()=>{M$1={type:"var",match:/\$\w+|\${[^}]*}|\$\([^)]*\)/g},T=[{sub:"todo",match:/#.*/g},{type:"str",match:/(["'])((?!\1)[^\r\n\\]|\\[^])*\1?/g,sub:[M$1]},{type:"oper",match:/(?<=\s|^)\.*\/[a-z/_.-]+/gi},{type:"kwd",match:/\s-[a-zA-Z]+|$<|[&|;]+|\b(unset|readonly|shift|export|if|fi|else|elif|while|do|done|for|until|case|esac|break|continue|exit|return|trap|wait|eval|exec|then|declare|enable|local|select|typeset|time|add|remove|install|update|delete)(?=\s|$)/g},{expand:"num"},{type:"func",match:/(?<=(^|\||\&\&|\;)\s*)[a-z_.-]+(?=\s|$)/gmi},{type:"bool",match:/(?<=\s|^)(true|false)(?=\s|$)/g},{type:"oper",match:/[=(){}<>!]+/g},{type:"var",match:/(?<=\s|^)[\w_]+(?=\s*=)/g},M$1];});var v$1={};p(v$1,{default:()=>jt$1});var jt$1,B$1=a$1(()=>{jt$1=[{match:/[^\[\->+.<\]\s].*/g,sub:"todo"},{type:"func",match:/\.+/g},{type:"kwd",match:/[<>]+/g},{type:"oper",match:/[+-]+/g}];});var G$1={};p(G$1,{default:()=>Kt$1});var Kt$1,H$1=a$1(()=>{Kt$1=[{match:/\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,sub:"todo"},{expand:"str"},{expand:"num"},{type:"kwd",match:/#\s*include (<.*>|".*")/g,sub:[{type:"str",match:/(<|").*/g}]},{match:/asm\s*{[^}]*}/g,sub:[{type:"kwd",match:/^asm/g},{match:/[^{}]*(?=}$)/g,sub:"asm"}]},{type:"kwd",match:/\*|&|#[a-z]+\b|\b(asm|auto|double|int|struct|break|else|long|switch|case|enum|register|typedef|char|extern|return|union|const|float|short|unsigned|continue|for|signed|void|default|goto|sizeof|volatile|do|if|static|while)\b/g},{type:"oper",match:/[/*+:?&|%^~=!,<>.^-]+/g},{type:"func",match:/[a-zA-Z_][\w_]*(?=\s*\()/g},{type:"class",match:/\b[A-Z][\w_]*\b/g}];});var k$1={};p(k$1,{default:()=>Vt$1});var Vt$1,_$1=a$1(()=>{Vt$1=[{match:/\/\*((?!\*\/)[^])*(\*\/)?/g,sub:"todo"},{expand:"str"},{type:"kwd",match:/@\w+\b|\b(and|not|only|or)\b|\b[a-z-]+(?=[^{}]*{)/g},{type:"var",match:/\b[\w-]+(?=\s*:)|(::?|\.)[\w-]+(?=[^{}]*{)/g},{type:"func",match:/#[\w-]+(?=[^{}]*{)/g},{type:"num",match:/#[\da-f]{3,8}/g},{type:"num",match:/\d+(\.\d+)?(cm|mm|in|px|pt|pc|em|ex|ch|rem|vm|vh|vmin|vmax|%)?/g,sub:[{type:"var",match:/[a-z]+|%/g}]},{match:/url\([^)]*\)/g,sub:[{type:"func",match:/url(?=\()/g},{type:"str",match:/[^()]+/g}]},{type:"func",match:/\b[a-zA-Z]\w*(?=\s*\()/g},{type:"num",match:/\b[a-z-]+\b/g}];});var z$1={};p(z$1,{default:()=>qt$1});var qt$1,Y$1=a$1(()=>{qt$1=[{expand:"strDouble"},{type:"oper",match:/,/g}];});var Z$1={};p(Z$1,{default:()=>I$1});var I$1,N$1=a$1(()=>{I$1=[{type:"deleted",match:/^[-<].*/gm},{type:"insert",match:/^[+>].*/gm},{type:"kwd",match:/!.*/gm},{type:"section",match:/^@@.*@@$|^\d.*|^([*-+])\1\1.*/gm}];});var X$1={};p(X$1,{default:()=>Qt});var Qt,W$1=a$1(()=>{f();Qt=[{type:"kwd",match:/^(FROM|RUN|CMD|LABEL|MAINTAINER|EXPOSE|ENV|ADD|COPY|ENTRYPOINT|VOLUME|USER|WORKDIR|ARG|ONBUILD|STOPSIGNAL|HEALTHCHECK|SHELL)\b/gmi},...T];});var j$1={};p(j$1,{default:()=>Jt$1});var Jt$1,K$1=a$1(()=>{N$1();Jt$1=[{match:/^#.*/gm,sub:"todo"},{expand:"str"},...I$1,{type:"func",match:/^(\$ )?git(\s.*)?$/gm},{type:"kwd",match:/^commit \w+$/gm}];});var V$1={};p(V$1,{default:()=>te$1});var te$1,q$1=a$1(()=>{te$1=[{match:/\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,sub:"todo"},{expand:"str"},{expand:"num"},{type:"kwd",match:/\*|&|\b(break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go|goto|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/g},{type:"func",match:/[a-zA-Z_][\w_]*(?=\s*\()/g},{type:"class",match:/\b[A-Z][\w_]*\b/g},{type:"oper",match:/[+\-*\/%&|^~=!<>.^-]+/g}];});var J$1={};p(J$1,{default:()=>A$1,name:()=>E$1,properties:()=>l$1,xmlElement:()=>o});var Q$1,ee$1,E$1,l$1,o,A$1,R$1=a$1(()=>{Q$1=":A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD",ee$1=Q$1+"\\-\\.0-9\xB7\u0300-\u036F\u203F-\u2040",E$1=`[${Q$1}][${ee$1}]*`,l$1=`\\s*(\\s+${E$1}\\s*(=\\s*([^"']\\S*|("|')(\\\\[^]|(?!\\4)[^])*\\4?)?)?\\s*)*`,o={match:RegExp(`<[/!?]?${E$1}${l$1}[/!?]?>`,"g"),sub:[{type:"var",match:RegExp(`^<[/!?]?${E$1}`,"g"),sub:[{type:"oper",match:/^<[\/!?]?/g}]},{type:"str",match:/=\s*([^"']\S*|("|')(\\[^]|(?!\2)[^])*\2?)/g,sub:[{type:"oper",match:/^=/g}]},{type:"oper",match:/[\/!?]?>/g},{type:"class",match:RegExp(E$1,"g")}]},A$1=[{match:/<!--((?!-->)[^])*-->/g,sub:"todo"},{type:"class",match:/<!\[CDATA\[[\s\S]*?\]\]>/gi},o,{type:"str",match:RegExp(`<\\?${E$1}([^?]|\\?[^?>])*\\?+>`,"g"),sub:[{type:"var",match:RegExp(`^<\\?${E$1}`,"g"),sub:[{type:"oper",match:/^<\?/g}]},{type:"oper",match:/\?+>$/g}]},{type:"var",match:/&(#x?)?[\da-z]{1,8};/gi}];});var tt$1={};p(tt$1,{default:()=>ae$1});var ae$1,et$1=a$1(()=>{R$1();ae$1=[{type:"class",match:/<!DOCTYPE("[^"]*"|'[^']*'|[^"'>])*>/gi,sub:[{type:"str",match:/"[^"]*"|'[^']*'/g},{type:"oper",match:/^<!|>$/g},{type:"var",match:/DOCTYPE/gi}]},{match:RegExp(`<style${l$1}>((?!</style>)[^])*</style\\s*>`,"g"),sub:[{match:RegExp(`^<style${l$1}>`,"g"),sub:o.sub},{match:RegExp(`${o.match}|[^]*(?=</style\\s*>$)`,"g"),sub:"css"},o]},{match:RegExp(`<script${l$1}>((?!<\/script>)[^])*<\/script\\s*>`,"g"),sub:[{match:RegExp(`^<script${l$1}>`,"g"),sub:o.sub},{match:RegExp(`${o.match}|[^]*(?=<\/script\\s*>$)`,"g"),sub:"js"},o]},...A$1];});var pe$1,u$1,d$1=a$1(()=>{pe$1=[["bash",[/#!(\/usr)?\/bin\/bash/g,500],[/\b(if|elif|then|fi|echo)\b|\$/g,10]],["html",[/<\/?[a-z-]+[^\n>]*>/g,10],[/^\s+<!DOCTYPE\s+html/g,500]],["http",[/^(GET|HEAD|POST|PUT|DELETE|PATCH|HTTP)\b/g,500]],["js",[/\b(console|await|async|function|export|import|this|class|for|let|const|map|join|require)\b/g,10]],["ts",[/\b(console|await|async|function|export|import|this|class|for|let|const|map|join|require|implements|interface|namespace)\b/g,10]],["py",[/\b(def|print|class|and|or|lambda)\b/g,10]],["sql",[/\b(SELECT|INSERT|FROM)\b/g,50]],["pl",[/#!(\/usr)?\/bin\/perl/g,500],[/\b(use|print)\b|\$/g,10]],["lua",[/#!(\/usr)?\/bin\/lua/g,500]],["make",[/\b(ifneq|endif|if|elif|then|fi|echo|.PHONY|^[a-z]+ ?:$)\b|\$/gm,10]],["uri",[/https?:|mailto:|tel:|ftp:/g,30]],["css",[/^(@import|@page|@media|(\.|#)[a-z]+)/gm,20]],["diff",[/^[+><-]/gm,10],[/^@@ ?[-+,0-9 ]+ ?@@/gm,25]],["md",[/^(>|\t\*|\t\d+.)/gm,10],[/\[.*\](.*)/g,10]],["docker",[/^(FROM|ENTRYPOINT|RUN)/gm,500]],["xml",[/<\/?[a-z-]+[^\n>]*>/g,10],[/^<\?xml/g,500]],["c",[/#include\b|\bprintf\s+\(/g,100]],["rs",[/^\s+(use|fn|mut|match)\b/gm,100]],["go",[/\b(func|fmt|package)\b/g,100]],["java",[/^import\s+java/gm,500]],["asm",[/^(section|global main|extern|\t(call|mov|ret))/gm,100]],["css",[/^(@import|@page|@media|(\.|#)[a-z]+)/gm,20]],["json",[/\b(true|false|null|\{})\b|\"[^"]+\":/g,10]],["yaml",[/^(\s+)?[a-z][a-z0-9]*:/gmi,10]]],u$1=t=>pe$1.map(([e,...s])=>[e,s.reduce((c,[m,n])=>c+[...t.matchAll(m)].length*n,0)]).filter(([e,s])=>s>20).sort((e,s)=>s[1]-e[1])[0]?.[0]||"plain";});var at$1={};p(at$1,{default:()=>se$1});var se$1,pt$1=a$1(()=>{d$1();se$1=[{type:"kwd",match:/^(GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|PRI|SEARCH)\b/gm},{expand:"str"},{type:"section",match:/\bHTTP\/[\d.]+\b/g},{expand:"num"},{type:"oper",match:/[,;:=]/g},{type:"var",match:/[a-zA-Z][\w-]*(?=:)/g},{match:/\n\n[^]*/g,sub:u$1}];});var st$1={};p(st$1,{default:()=>ce$1});var ce$1,ct$1=a$1(()=>{ce$1=[{match:/(^[ \f\t\v]*)[#;].*/gm,sub:"todo"},{type:"str",match:/.*/g},{type:"var",match:/.*(?==)/g},{type:"section",match:/^\s*\[.+\]\s*$/gm},{type:"oper",match:/=/g}];});var nt$1={};p(nt$1,{default:()=>ne$1});var ne$1,mt$1=a$1(()=>{ne$1=[{match:/\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,sub:"todo"},{expand:"str"},{expand:"num"},{type:"kwd",match:/\b(abstract|assert|boolean|break|byte|case|catch|char|class|continue|const|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|package|private|protected|public|requires|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|transient|try|var|void|volatile|while)\b/g},{type:"oper",match:/[/*+:?&|%^~=!,<>.^-]+/g},{type:"func",match:/[a-zA-Z_][\w_]*(?=\s*\()/g},{type:"class",match:/\b[A-Z][\w_]*\b/g}];});var rt$1={};p(rt$1,{default:()=>O$1});var O$1,L$1=a$1(()=>{O$1=[{match:/\/\*\*((?!\*\/)[^])*(\*\/)?/g,sub:"jsdoc"},{match:/\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,sub:"todo"},{expand:"str"},{match:/`((?!`)[^]|\\[^])*`?/g,sub:"js_template_literals"},{type:"kwd",match:/=>|\b(this|set|get|as|async|await|break|case|catch|class|const|constructor|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|if|implements|import|in|instanceof|interface|let|var|of|new|package|private|protected|public|return|static|super|switch|throw|throws|try|typeof|void|while|with|yield)\b/g},{match:/\/((?!\/)[^\r\n\\]|\\.)+\/[dgimsuy]*/g,sub:"regex"},{expand:"num"},{type:"num",match:/\b(NaN|null|undefined|[A-Z][A-Z_]*)\b/g},{type:"bool",match:/\b(true|false)\b/g},{type:"oper",match:/[/*+:?&|%^~=!,<>.^-]+/g},{type:"class",match:/\b[A-Z][\w_]*\b/g},{type:"func",match:/[a-zA-Z$_][\w$_]*(?=\s*((\?\.)?\s*\(|=\s*(\(?[\w,{}\[\])]+\)? =>|function\b)))/g}];});var ot$1={};p(ot$1,{default:()=>me$1,type:()=>re$1});var me$1,re$1,Et$1=a$1(()=>{me$1=[{match:new class{exec(t){let e=this.lastIndex,s,c=m=>{for(;++e<t.length-2;)if(t[e]=="{")c();else if(t[e]=="}")return};for(;e<t.length;++e)if(t[e-1]!="\\"&&t[e]=="$"&&t[e+1]=="{")return s=e++,c(),this.lastIndex=e+1,{index:s,0:t.slice(s,e+1)};return null}},sub:[{type:"kwd",match:/^\${|}$/g},{match:/(?!^\$|{)[^]+(?=}$)/g,sub:"js"}]}],re$1="str";});var lt$1={};p(lt$1,{default:()=>x$1,type:()=>oe$1});var x$1,oe$1,S$1=a$1(()=>{x$1=[{type:"err",match:/\b(TODO|FIXME|DEBUG|OPTIMIZE|WARNING|XXX|BUG)\b/g},{type:"class",match:/\bIDEA\b/g},{type:"insert",match:/\b(CHANGED|FIX|CHANGE)\b/g},{type:"oper",match:/\bQUESTION\b/g}],oe$1="cmnt";});var ut$1={};p(ut$1,{default:()=>Ee$1,type:()=>le$1});var Ee$1,le$1,ht$1=a$1(()=>{S$1();Ee$1=[{type:"kwd",match:/@\w+/g},{type:"class",match:/{[\w\s|<>,.@\[\]]+}/g},{type:"var",match:/\[[\w\s="']+\]/g},...x$1],le$1="cmnt";});var it$1={};p(it$1,{default:()=>ue$1});var ue$1,gt$1=a$1(()=>{ue$1=[{type:"var",match:/("|')?[a-zA-Z]\w*\1(?=\s*:)/g},{expand:"str"},{expand:"num"},{type:"num",match:/\bnull\b/g},{type:"bool",match:/\b(true|false)\b/g}];});var dt$1={};p(dt$1,{default:()=>C$1});var C$1,D$1=a$1(()=>{d$1();C$1=[{type:"cmnt",match:/^>.*|(=|-)\1+/gm},{type:"class",match:/\*\*((?!\*\*).)*\*\*/g},{match:/```((?!```)[^])*\n```/g,sub:t=>({type:"kwd",sub:[{match:/\n[^]*(?=```)/g,sub:t.split(`
`)[0].slice(3)||u$1(t)}]})},{type:"str",match:/`[^`]*`/g},{type:"var",match:/~~((?!~~).)*~~/g},{type:"kwd",match:/_[^_]*_|\*[^*]*\*/g},{type:"kwd",match:/^\s*(\*|\d+\.)\s/gm},{type:"oper",match:/\[[^\]]*]/g},{type:"func",match:/\([^)]*\)/g}];});var bt$1={};p(bt$1,{default:()=>he$1});var he$1,yt$1=a$1(()=>{D$1();d$1();he$1=[{type:"insert",match:/(leanpub-start-insert)((?!leanpub-end-insert)[^])*(leanpub-end-insert)?/g,sub:[{type:"insert",match:/leanpub-(start|end)-insert/g},{match:/(?!leanpub-start-insert)((?!leanpub-end-insert)[^])*/g,sub:u$1}]},{type:"deleted",match:/(leanpub-start-delete)((?!leanpub-end-delete)[^])*(leanpub-end-delete)?/g,sub:[{type:"deleted",match:/leanpub-(start|end)-delete/g},{match:/(?!leanpub-start-delete)((?!leanpub-end-delete)[^])*/g,sub:u$1}]},...C$1];});var Tt$1={};p(Tt$1,{default:()=>ie$1});var ie$1,ft$1=a$1(()=>{ie$1=[{type:"cmnt",match:/^#.*/gm},{expand:"strDouble"},{expand:"num"},{type:"err",match:/\b(err(or)?|[a-z_-]*exception|warn|warning|failed|ko|invalid|not ?found|alert|fatal)\b/gi},{type:"num",match:/\b(null|undefined)\b/gi},{type:"bool",match:/\b(false|true|yes|no)\b/gi},{type:"oper",match:/\.|,/g}];});var It$1={};p(It$1,{default:()=>ge$1});var ge$1,Nt$1=a$1(()=>{ge$1=[{match:/^#!.*|--(\[(=*)\[((?!--\]\2\])[^])*--\]\2\]|.*)/g,sub:"todo"},{expand:"str"},{type:"kwd",match:/\b(and|break|do|else|elseif|end|for|function|if|in|local|not|or|repeat|return|then|until|while)\b/g},{type:"bool",match:/\b(true|false|nil)\b/g},{type:"oper",match:/[+*/%^#=~<>:,.-]+/g},{expand:"num"},{type:"func",match:/[a-z_]+(?=\s*[({])/g}];});var At$1={};p(At$1,{default:()=>de$1});var de$1,Rt$1=a$1(()=>{de$1=[{match:/^\s*#.*/gm,sub:"todo"},{expand:"str"},{type:"oper",match:/[${}()]+/g},{type:"class",match:/.PHONY:/gm},{type:"section",match:/^[\w.]+:/gm},{type:"kwd",match:/\b(ifneq|endif)\b/g},{expand:"num"},{type:"var",match:/[A-Z_]+(?=\s*=)/g},{match:/^.*$/gm,sub:"bash"}];});var Ot$1={};p(Ot$1,{default:()=>be$1});var be$1,Lt$1=a$1(()=>{be$1=[{match:/#.*/g,sub:"todo"},{type:"str",match:/(["'])(\\[^]|(?!\1)[^])*\1?/g},{expand:"num"},{type:"kwd",match:/\b(any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while|not|and|or|xor)\b/g},{type:"oper",match:/[-+*/%~!&<>|=?,]+/g},{type:"func",match:/[a-z_]+(?=\s*\()/g}];});var xt$1={};p(xt$1,{default:()=>ye$1});var ye$1,St$1=a$1(()=>{ye$1=[{expand:"strDouble"}];});var Ct$1={};p(Ct$1,{default:()=>Te$1});var Te$1,Dt$1=a$1(()=>{Te$1=[{match:/#.*/g,sub:"todo"},{match:/("""|''')(\\[^]|(?!\1)[^])*\1?/g,sub:"todo"},{type:"str",match:/f("|')(\\[^]|(?!\1).)*\1?|f((["'])\4\4)(\\[^]|(?!\3)[^])*\3?/gi,sub:[{type:"var",match:/{[^{}]*}/g,sub:[{match:/(?!^{)[^]*(?=}$)/g,sub:"py"}]}]},{expand:"str"},{type:"kwd",match:/\b(and|as|assert|break|class|continue|def|del|elif|else|except|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|raise|return|try|while|with|yield)\b/g},{type:"bool",match:/\b(False|True|None)\b/g},{expand:"num"},{type:"func",match:/[a-z_]+(?=\s*\()/g},{type:"oper",match:/[-/*+<>,=!&|^%]+/g},{type:"class",match:/\b[A-Z][\w_]*\b/g}];});var wt$1={};p(wt$1,{default:()=>fe$1,type:()=>Ie$1});var fe$1,Ie$1,Ut$1=a$1(()=>{fe$1=[{match:/^(?!\/).*/gm,sub:"todo"},{type:"num",match:/\[((?!\])[^\\]|\\.)*\]/g},{type:"kwd",match:/\||\^|\$|\\.|\w+($|\r|\n)/g},{type:"var",match:/\*|\+|\{\d+,\d+\}/g}],Ie$1="oper";});var Pt$1={};p(Pt$1,{default:()=>Ne$1});var Ne$1,Ft$1=a$1(()=>{Ne$1=[{match:/\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,sub:"todo"},{expand:"str"},{expand:"num"},{type:"kwd",match:/\b(as|break|const|continue|crate|else|enum|extern|false|fn|for|if|impl|in|let|loop|match|mod|move|mut|pub|ref|return|self|Self|static|struct|super|trait|true|type|unsafe|use|where|while|async|await|dyn|abstract|become|box|do|final|macro|override|priv|typeof|unsized|virtual|yield|try)\b/g},{type:"oper",match:/[/*+:?&|%^~=!,<>.^-]+/g},{type:"class",match:/\b[A-Z][\w_]*\b/g},{type:"func",match:/[a-zA-Z_][\w_]*(?=\s*!?\s*\()/g}];});var Mt$1={};p(Mt$1,{default:()=>Ae$1});var Ae$1,$t$1=a$1(()=>{Ae$1=[{match:/--.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,sub:"todo"},{expand:"str"},{type:"func",match:/\b(AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/g},{type:"kwd",match:/\b(ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|kwdS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:S|ING)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/g},{type:"num",match:/\.?\d[\d.oxa-fA-F-]*|\bNULL\b/g},{type:"bool",match:/\b(TRUE|FALSE)\b/g},{type:"oper",match:/[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|IN|ILIKE|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/g},{type:"var",match:/@\S+/g}];});var vt$1={};p(vt$1,{default:()=>Re$1});var Re$1,Bt$1=a$1(()=>{Re$1=[{match:/#.*/g,sub:"todo"},{type:"str",match:/("""|''')((?!\1)[^]|\\[^])*\1?/g},{expand:"str"},{type:"section",match:/^\[.+\]\s*$/gm},{type:"num",match:/\b(inf|nan)\b|\d[\d:ZT.-]*/g},{expand:"num"},{type:"bool",match:/\b(true|false)\b/g},{type:"oper",match:/[+,.=-]/g},{type:"var",match:/\w+(?= \=)/g}];});var Gt$1={};p(Gt$1,{default:()=>Oe$1});var Oe$1,Ht$1=a$1(()=>{L$1();Oe$1=[{type:"type",match:/:\s*(any|void|number|boolean|string|object|never|enum)\b/g},{type:"kwd",match:/\b(type|namespace|typedef|interface|public|private|protected|implements|declare|abstract|readonly)\b/g},...O$1];});var kt$1={};p(kt$1,{default:()=>Le$1});var Le$1,_t$1=a$1(()=>{Le$1=[{match:/^#.*/gm,sub:"todo"},{type:"class",match:/^\w+(?=:?)/gm},{type:"num",match:/:\d+/g},{type:"oper",match:/[:/&?]|\w+=/g},{type:"func",match:/[.\w]+@|#[\w]+$/gm},{type:"var",match:/\w+\.\w+(\.\w+)*/g}];});var zt$1={};p(zt$1,{default:()=>xe$1});var xe$1,Yt$1=a$1(()=>{xe$1=[{match:/#.*/g,sub:"todo"},{expand:"str"},{type:"str",match:/(>|\|)\r?\n((\s[^\n]*)?(\r?\n|$))*/g},{type:"type",match:/!![a-z]+/g},{type:"bool",match:/\b(Yes|No)\b/g},{type:"oper",match:/[+:-]/g},{expand:"num"},{type:"var",match:/[a-zA-Z]\w*(?=:)/g}];});var U$1={num:{type:"num",match:/(\.e?|\b)\d(e-|[\d.oxa-fA-F_])*(\.|\b)/g},str:{type:"str",match:/(["'])(\\[^]|(?!\1)[^\r\n\\])*\1?/g},strDouble:{type:"str",match:/"((?!")[^\r\n\\]|\\[^])*"?/g}};var Se$1=w$1({"./languages/asm.js":()=>Promise.resolve().then(()=>(F$1(),P$1)),"./languages/bash.js":()=>Promise.resolve().then(()=>(f(),$$1)),"./languages/bf.js":()=>Promise.resolve().then(()=>(B$1(),v$1)),"./languages/c.js":()=>Promise.resolve().then(()=>(H$1(),G$1)),"./languages/css.js":()=>Promise.resolve().then(()=>(_$1(),k$1)),"./languages/csv.js":()=>Promise.resolve().then(()=>(Y$1(),z$1)),"./languages/diff.js":()=>Promise.resolve().then(()=>(N$1(),Z$1)),"./languages/docker.js":()=>Promise.resolve().then(()=>(W$1(),X$1)),"./languages/git.js":()=>Promise.resolve().then(()=>(K$1(),j$1)),"./languages/go.js":()=>Promise.resolve().then(()=>(q$1(),V$1)),"./languages/html.js":()=>Promise.resolve().then(()=>(et$1(),tt$1)),"./languages/http.js":()=>Promise.resolve().then(()=>(pt$1(),at$1)),"./languages/ini.js":()=>Promise.resolve().then(()=>(ct$1(),st$1)),"./languages/java.js":()=>Promise.resolve().then(()=>(mt$1(),nt$1)),"./languages/js.js":()=>Promise.resolve().then(()=>(L$1(),rt$1)),"./languages/js_template_literals.js":()=>Promise.resolve().then(()=>(Et$1(),ot$1)),"./languages/jsdoc.js":()=>Promise.resolve().then(()=>(ht$1(),ut$1)),"./languages/json.js":()=>Promise.resolve().then(()=>(gt$1(),it$1)),"./languages/leanpub-md.js":()=>Promise.resolve().then(()=>(yt$1(),bt$1)),"./languages/log.js":()=>Promise.resolve().then(()=>(ft$1(),Tt$1)),"./languages/lua.js":()=>Promise.resolve().then(()=>(Nt$1(),It$1)),"./languages/make.js":()=>Promise.resolve().then(()=>(Rt$1(),At$1)),"./languages/md.js":()=>Promise.resolve().then(()=>(D$1(),dt$1)),"./languages/pl.js":()=>Promise.resolve().then(()=>(Lt$1(),Ot$1)),"./languages/plain.js":()=>Promise.resolve().then(()=>(St$1(),xt$1)),"./languages/py.js":()=>Promise.resolve().then(()=>(Dt$1(),Ct$1)),"./languages/regex.js":()=>Promise.resolve().then(()=>(Ut$1(),wt$1)),"./languages/rs.js":()=>Promise.resolve().then(()=>(Ft$1(),Pt$1)),"./languages/sql.js":()=>Promise.resolve().then(()=>($t$1(),Mt$1)),"./languages/todo.js":()=>Promise.resolve().then(()=>(S$1(),lt$1)),"./languages/toml.js":()=>Promise.resolve().then(()=>(Bt$1(),vt$1)),"./languages/ts.js":()=>Promise.resolve().then(()=>(Ht$1(),Gt$1)),"./languages/uri.js":()=>Promise.resolve().then(()=>(_t$1(),kt$1)),"./languages/xml.js":()=>Promise.resolve().then(()=>(R$1(),J$1)),"./languages/yaml.js":()=>Promise.resolve().then(()=>(Yt$1(),zt$1))});var b$1={},Ce$1=(t="")=>t.replaceAll("&","&#38;").replaceAll?.("<","&lt;").replaceAll?.(">","&gt;"),De$1=(t,e)=>e?`<span class="shj-syn-${e}">${t}</span>`:t;async function Zt$1(t,e,s){try{let c,m,n={},i,r=[],h=0,y=typeof e=="string"?await(b$1[e]??(b$1[e]=Se$1(`./languages/${e}.js`))):e,g=[...typeof e=="string"?y.default:e.sub];for(;h<t.length;){for(n.index=null,c=g.length;c-- >0;){if(m=g[c].expand?U$1[g[c].expand]:g[c],r[c]===void 0||r[c].match.index<h){if(m.match.lastIndex=h,i=m.match.exec(t),i===null){g.splice(c,1),r.splice(c,1);continue}r[c]={match:i,lastIndex:m.match.lastIndex};}r[c].match[0]&&(r[c].match.index<=n.index||n.index===null)&&(n={part:m,index:r[c].match.index,match:r[c].match[0],end:r[c].lastIndex});}if(n.index===null)break;s(t.slice(h,n.index),y.type),h=n.end,n.part.sub?await Zt$1(n.match,typeof n.part.sub=="string"?n.part.sub:typeof n.part.sub=="function"?n.part.sub(n.match):n.part,s):s(n.match,n.part.type);}s(t.slice(h,t.length),y.type);}catch{s(t);}}async function we$1(t,e,s=true,c={}){let m="";return await Zt$1(t,e,(n,i)=>m+=De$1(Ce$1(n),i)),s?`<div><div class="shj-numbers">${"<div></div>".repeat(!c.hideLineNumbers&&t.split(`
`).length)}</div><div>${m}</div></div>`:m}

var te=Object.defineProperty;var d=p=>t=>{var s=p[t];if(s)return s();throw new Error("Module not found in bundle: "+t)};var e=(p,t)=>()=>(p&&(t=p(p=0)),t);var a=(p,t)=>{for(var s in t)te(p,s,{get:t[s],enumerable:true});};var B={};a(B,{default:()=>ee});var ee,G=e(()=>{ee=[{type:"cmnt",match:/(;|#).*/gm},{expand:"str"},{expand:"num"},{type:"num",match:/\$[\da-fA-F]*\b/g},{type:"kwd",match:/^[a-z]+\s+[a-z.]+\b/gm,sub:[{type:"func",match:/^[a-z]+/g}]},{type:"kwd",match:/^\t*[a-z][a-z\d]*\b/gm},{match:/%|\$/g,type:"oper"}];});var H={};a(H,{default:()=>I});var k,I,N=e(()=>{k={type:"var",match:/\$\w+|\${[^}]*}|\$\([^)]*\)/g},I=[{sub:"todo",match:/#.*/g},{type:"str",match:/(["'])((?!\1)[^\r\n\\]|\\[^])*\1?/g,sub:[k]},{type:"oper",match:/(?<=\s|^)\.*\/[a-z/_.-]+/gi},{type:"kwd",match:/\s-[a-zA-Z]+|$<|[&|;]+|\b(unset|readonly|shift|export|if|fi|else|elif|while|do|done|for|until|case|esac|break|continue|exit|return|trap|wait|eval|exec|then|declare|enable|local|select|typeset|time|add|remove|install|update|delete)(?=\s|$)/g},{expand:"num"},{type:"func",match:/(?<=(^|\||\&\&|\;)\s*)[a-z_.-]+(?=\s|$)/gmi},{type:"bool",match:/(?<=\s|^)(true|false)(?=\s|$)/g},{type:"oper",match:/[=(){}<>!]+/g},{type:"var",match:/(?<=\s|^)[\w_]+(?=\s*=)/g},k];});var z={};a(z,{default:()=>ae});var ae,_=e(()=>{ae=[{match:/[^\[\->+.<\]\s].*/g,sub:"todo"},{type:"func",match:/\.+/g},{type:"kwd",match:/[<>]+/g},{type:"oper",match:/[+-]+/g}];});var Y={};a(Y,{default:()=>pe});var pe,Z=e(()=>{pe=[{match:/\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,sub:"todo"},{expand:"str"},{expand:"num"},{type:"kwd",match:/#\s*include (<.*>|".*")/g,sub:[{type:"str",match:/(<|").*/g}]},{match:/asm\s*{[^}]*}/g,sub:[{type:"kwd",match:/^asm/g},{match:/[^{}]*(?=}$)/g,sub:"asm"}]},{type:"kwd",match:/\*|&|#[a-z]+\b|\b(asm|auto|double|int|struct|break|else|long|switch|case|enum|register|typedef|char|extern|return|union|const|float|short|unsigned|continue|for|signed|void|default|goto|sizeof|volatile|do|if|static|while)\b/g},{type:"oper",match:/[/*+:?&|%^~=!,<>.^-]+/g},{type:"func",match:/[a-zA-Z_][\w_]*(?=\s*\()/g},{type:"class",match:/\b[A-Z][\w_]*\b/g}];});var X={};a(X,{default:()=>ne});var ne,W=e(()=>{ne=[{match:/\/\*((?!\*\/)[^])*(\*\/)?/g,sub:"todo"},{expand:"str"},{type:"kwd",match:/@\w+\b|\b(and|not|only|or)\b|\b[a-z-]+(?=[^{}]*{)/g},{type:"var",match:/\b[\w-]+(?=\s*:)|(::?|\.)[\w-]+(?=[^{}]*{)/g},{type:"func",match:/#[\w-]+(?=[^{}]*{)/g},{type:"num",match:/#[\da-f]{3,8}/g},{type:"num",match:/\d+(\.\d+)?(cm|mm|in|px|pt|pc|em|ex|ch|rem|vm|vh|vmin|vmax|%)?/g,sub:[{type:"var",match:/[a-z]+|%/g}]},{match:/url\([^)]*\)/g,sub:[{type:"func",match:/url(?=\()/g},{type:"str",match:/[^()]+/g}]},{type:"func",match:/\b[a-zA-Z]\w*(?=\s*\()/g},{type:"num",match:/\b[a-z-]+\b/g}];});var j={};a(j,{default:()=>se});var se,K=e(()=>{se=[{expand:"strDouble"},{type:"oper",match:/,/g}];});var V={};a(V,{default:()=>A});var A,R=e(()=>{A=[{type:"deleted",match:/^[-<].*/gm},{type:"insert",match:/^[+>].*/gm},{type:"kwd",match:/!.*/gm},{type:"section",match:/^@@.*@@$|^\d.*|^([*-+])\1\1.*/gm}];});var q={};a(q,{default:()=>re});var re,Q=e(()=>{N();re=[{type:"kwd",match:/^(FROM|RUN|CMD|LABEL|MAINTAINER|EXPOSE|ENV|ADD|COPY|ENTRYPOINT|VOLUME|USER|WORKDIR|ARG|ONBUILD|STOPSIGNAL|HEALTHCHECK|SHELL)\b/gmi},...I];});var J={};a(J,{default:()=>ce});var ce,tt=e(()=>{R();ce=[{match:/^#.*/gm,sub:"todo"},{expand:"str"},...A,{type:"func",match:/^(\$ )?git(\s.*)?$/gm},{type:"kwd",match:/^commit \w+$/gm}];});var et={};a(et,{default:()=>me});var me,at=e(()=>{me=[{match:/\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,sub:"todo"},{expand:"str"},{expand:"num"},{type:"kwd",match:/\*|&|\b(break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go|goto|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/g},{type:"func",match:/[a-zA-Z_][\w_]*(?=\s*\()/g},{type:"class",match:/\b[A-Z][\w_]*\b/g},{type:"oper",match:/[+\-*\/%&|^~=!<>.^-]+/g}];});var nt={};a(nt,{default:()=>O,name:()=>u,properties:()=>E,xmlElement:()=>l});var pt,oe,u,E,l,O,x=e(()=>{pt=":A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD",oe=pt+"\\-\\.0-9\xB7\u0300-\u036F\u203F-\u2040",u=`[${pt}][${oe}]*`,E=`\\s*(\\s+${u}\\s*(=\\s*([^"']\\S*|("|')(\\\\[^]|(?!\\4)[^])*\\4?)?)?\\s*)*`,l={match:RegExp(`<[/!?]?${u}${E}[/!?]?>`,"g"),sub:[{type:"var",match:RegExp(`^<[/!?]?${u}`,"g"),sub:[{type:"oper",match:/^<[\/!?]?/g}]},{type:"str",match:/=\s*([^"']\S*|("|')(\\[^]|(?!\2)[^])*\2?)/g,sub:[{type:"oper",match:/^=/g}]},{type:"oper",match:/[\/!?]?>/g},{type:"class",match:RegExp(u,"g")}]},O=[{match:/<!--((?!-->)[^])*-->/g,sub:"todo"},{type:"class",match:/<!\[CDATA\[[\s\S]*?\]\]>/gi},l,{type:"str",match:RegExp(`<\\?${u}([^?]|\\?[^?>])*\\?+>`,"g"),sub:[{type:"var",match:RegExp(`^<\\?${u}`,"g"),sub:[{type:"oper",match:/^<\?/g}]},{type:"oper",match:/\?+>$/g}]},{type:"var",match:/&(#x?)?[\da-z]{1,8};/gi}];});var st={};a(st,{default:()=>le});var le,rt=e(()=>{x();le=[{type:"class",match:/<!DOCTYPE("[^"]*"|'[^']*'|[^"'>])*>/gi,sub:[{type:"str",match:/"[^"]*"|'[^']*'/g},{type:"oper",match:/^<!|>$/g},{type:"var",match:/DOCTYPE/gi}]},{match:RegExp(`<style${E}>((?!</style>)[^])*</style\\s*>`,"g"),sub:[{match:RegExp(`^<style${E}>`,"g"),sub:l.sub},{match:RegExp(`${l.match}|[^]*(?=</style\\s*>$)`,"g"),sub:"css"},l]},{match:RegExp(`<script${E}>((?!<\/script>)[^])*<\/script\\s*>`,"g"),sub:[{match:RegExp(`^<script${E}>`,"g"),sub:l.sub},{match:RegExp(`${l.match}|[^]*(?=<\/script\\s*>$)`,"g"),sub:"js"},l]},...O];});var ue,i,b=e(()=>{ue=[["bash",[/#!(\/usr)?\/bin\/bash/g,500],[/\b(if|elif|then|fi|echo)\b|\$/g,10]],["html",[/<\/?[a-z-]+[^\n>]*>/g,10],[/^\s+<!DOCTYPE\s+html/g,500]],["http",[/^(GET|HEAD|POST|PUT|DELETE|PATCH|HTTP)\b/g,500]],["js",[/\b(console|await|async|function|export|import|this|class|for|let|const|map|join|require)\b/g,10]],["ts",[/\b(console|await|async|function|export|import|this|class|for|let|const|map|join|require|implements|interface|namespace)\b/g,10]],["py",[/\b(def|print|class|and|or|lambda)\b/g,10]],["sql",[/\b(SELECT|INSERT|FROM)\b/g,50]],["pl",[/#!(\/usr)?\/bin\/perl/g,500],[/\b(use|print)\b|\$/g,10]],["lua",[/#!(\/usr)?\/bin\/lua/g,500]],["make",[/\b(ifneq|endif|if|elif|then|fi|echo|.PHONY|^[a-z]+ ?:$)\b|\$/gm,10]],["uri",[/https?:|mailto:|tel:|ftp:/g,30]],["css",[/^(@import|@page|@media|(\.|#)[a-z]+)/gm,20]],["diff",[/^[+><-]/gm,10],[/^@@ ?[-+,0-9 ]+ ?@@/gm,25]],["md",[/^(>|\t\*|\t\d+.)/gm,10],[/\[.*\](.*)/g,10]],["docker",[/^(FROM|ENTRYPOINT|RUN)/gm,500]],["xml",[/<\/?[a-z-]+[^\n>]*>/g,10],[/^<\?xml/g,500]],["c",[/#include\b|\bprintf\s+\(/g,100]],["rs",[/^\s+(use|fn|mut|match)\b/gm,100]],["go",[/\b(func|fmt|package)\b/g,100]],["java",[/^import\s+java/gm,500]],["asm",[/^(section|global main|extern|\t(call|mov|ret))/gm,100]],["css",[/^(@import|@page|@media|(\.|#)[a-z]+)/gm,20]],["json",[/\b(true|false|null|\{})\b|\"[^"]+\":/g,10]],["yaml",[/^(\s+)?[a-z][a-z0-9]*:/gmi,10]]],i=p=>ue.map(([t,...s])=>[t,s.reduce((r,[m,c])=>r+[...p.matchAll(m)].length*c,0)]).filter(([t,s])=>s>20).sort((t,s)=>s[1]-t[1])[0]?.[0]||"plain";});var ct={};a(ct,{default:()=>Ee});var Ee,mt=e(()=>{b();Ee=[{type:"kwd",match:/^(GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|PRI|SEARCH)\b/gm},{expand:"str"},{type:"section",match:/\bHTTP\/[\d.]+\b/g},{expand:"num"},{type:"oper",match:/[,;:=]/g},{type:"var",match:/[a-zA-Z][\w-]*(?=:)/g},{match:/\n\n[^]*/g,sub:i}];});var ot={};a(ot,{default:()=>ie});var ie,lt=e(()=>{ie=[{match:/(^[ \f\t\v]*)[#;].*/gm,sub:"todo"},{type:"str",match:/.*/g},{type:"var",match:/.*(?==)/g},{type:"section",match:/^\s*\[.+\]\s*$/gm},{type:"oper",match:/=/g}];});var ut={};a(ut,{default:()=>he});var he,Et=e(()=>{he=[{match:/\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,sub:"todo"},{expand:"str"},{expand:"num"},{type:"kwd",match:/\b(abstract|assert|boolean|break|byte|case|catch|char|class|continue|const|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|package|private|protected|public|requires|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|transient|try|var|void|volatile|while)\b/g},{type:"oper",match:/[/*+:?&|%^~=!,<>.^-]+/g},{type:"func",match:/[a-zA-Z_][\w_]*(?=\s*\()/g},{type:"class",match:/\b[A-Z][\w_]*\b/g}];});var it={};a(it,{default:()=>L});var L,S=e(()=>{L=[{match:/\/\*\*((?!\*\/)[^])*(\*\/)?/g,sub:"jsdoc"},{match:/\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,sub:"todo"},{expand:"str"},{match:/`((?!`)[^]|\\[^])*`?/g,sub:"js_template_literals"},{type:"kwd",match:/=>|\b(this|set|get|as|async|await|break|case|catch|class|const|constructor|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|if|implements|import|in|instanceof|interface|let|var|of|new|package|private|protected|public|return|static|super|switch|throw|throws|try|typeof|void|while|with|yield)\b/g},{match:/\/((?!\/)[^\r\n\\]|\\.)+\/[dgimsuy]*/g,sub:"regex"},{expand:"num"},{type:"num",match:/\b(NaN|null|undefined|[A-Z][A-Z_]*)\b/g},{type:"bool",match:/\b(true|false)\b/g},{type:"oper",match:/[/*+:?&|%^~=!,<>.^-]+/g},{type:"class",match:/\b[A-Z][\w_]*\b/g},{type:"func",match:/[a-zA-Z$_][\w$_]*(?=\s*((\?\.)?\s*\(|=\s*(\(?[\w,{}\[\])]+\)? =>|function\b)))/g}];});var ht={};a(ht,{default:()=>ge,type:()=>de});var ge,de,gt=e(()=>{ge=[{match:new class{exec(p){let t=this.lastIndex,s,r=m=>{for(;++t<p.length-2;)if(p[t]=="{")r();else if(p[t]=="}")return};for(;t<p.length;++t)if(p[t-1]!="\\"&&p[t]=="$"&&p[t+1]=="{")return s=t++,r(),this.lastIndex=t+1,{index:s,0:p.slice(s,t+1)};return null}},sub:[{type:"kwd",match:/^\${|}$/g},{match:/(?!^\$|{)[^]+(?=}$)/g,sub:"js"}]}],de="str";});var dt={};a(dt,{default:()=>C,type:()=>be});var C,be,D=e(()=>{C=[{type:"err",match:/\b(TODO|FIXME|DEBUG|OPTIMIZE|WARNING|XXX|BUG)\b/g},{type:"class",match:/\bIDEA\b/g},{type:"insert",match:/\b(CHANGED|FIX|CHANGE)\b/g},{type:"oper",match:/\bQUESTION\b/g}],be="cmnt";});var bt={};a(bt,{default:()=>ye,type:()=>Te});var ye,Te,yt=e(()=>{D();ye=[{type:"kwd",match:/@\w+/g},{type:"class",match:/{[\w\s|<>,.@\[\]]+}/g},{type:"var",match:/\[[\w\s="']+\]/g},...C],Te="cmnt";});var Tt={};a(Tt,{default:()=>fe});var fe,ft=e(()=>{fe=[{type:"var",match:/("|')?[a-zA-Z]\w*\1(?=\s*:)/g},{expand:"str"},{expand:"num"},{type:"num",match:/\bnull\b/g},{type:"bool",match:/\b(true|false)\b/g}];});var It={};a(It,{default:()=>w});var w,U=e(()=>{b();w=[{type:"cmnt",match:/^>.*|(=|-)\1+/gm},{type:"class",match:/\*\*((?!\*\*).)*\*\*/g},{match:/```((?!```)[^])*\n```/g,sub:p=>({type:"kwd",sub:[{match:/\n[^]*(?=```)/g,sub:p.split(`
`)[0].slice(3)||i(p)}]})},{type:"str",match:/`[^`]*`/g},{type:"var",match:/~~((?!~~).)*~~/g},{type:"kwd",match:/_[^_]*_|\*[^*]*\*/g},{type:"kwd",match:/^\s*(\*|\d+\.)\s/gm},{type:"oper",match:/\[[^\]]*]/g},{type:"func",match:/\([^)]*\)/g}];});var Nt={};a(Nt,{default:()=>Ie});var Ie,At=e(()=>{U();b();Ie=[{type:"insert",match:/(leanpub-start-insert)((?!leanpub-end-insert)[^])*(leanpub-end-insert)?/g,sub:[{type:"insert",match:/leanpub-(start|end)-insert/g},{match:/(?!leanpub-start-insert)((?!leanpub-end-insert)[^])*/g,sub:i}]},{type:"deleted",match:/(leanpub-start-delete)((?!leanpub-end-delete)[^])*(leanpub-end-delete)?/g,sub:[{type:"deleted",match:/leanpub-(start|end)-delete/g},{match:/(?!leanpub-start-delete)((?!leanpub-end-delete)[^])*/g,sub:i}]},...w];});var Rt={};a(Rt,{default:()=>Ne});var Ne,Ot=e(()=>{Ne=[{type:"cmnt",match:/^#.*/gm},{expand:"strDouble"},{expand:"num"},{type:"err",match:/\b(err(or)?|[a-z_-]*exception|warn|warning|failed|ko|invalid|not ?found|alert|fatal)\b/gi},{type:"num",match:/\b(null|undefined)\b/gi},{type:"bool",match:/\b(false|true|yes|no)\b/gi},{type:"oper",match:/\.|,/g}];});var xt={};a(xt,{default:()=>Ae});var Ae,Lt=e(()=>{Ae=[{match:/^#!.*|--(\[(=*)\[((?!--\]\2\])[^])*--\]\2\]|.*)/g,sub:"todo"},{expand:"str"},{type:"kwd",match:/\b(and|break|do|else|elseif|end|for|function|if|in|local|not|or|repeat|return|then|until|while)\b/g},{type:"bool",match:/\b(true|false|nil)\b/g},{type:"oper",match:/[+*/%^#=~<>:,.-]+/g},{expand:"num"},{type:"func",match:/[a-z_]+(?=\s*[({])/g}];});var St={};a(St,{default:()=>Re});var Re,Ct=e(()=>{Re=[{match:/^\s*#.*/gm,sub:"todo"},{expand:"str"},{type:"oper",match:/[${}()]+/g},{type:"class",match:/.PHONY:/gm},{type:"section",match:/^[\w.]+:/gm},{type:"kwd",match:/\b(ifneq|endif)\b/g},{expand:"num"},{type:"var",match:/[A-Z_]+(?=\s*=)/g},{match:/^.*$/gm,sub:"bash"}];});var Dt={};a(Dt,{default:()=>Oe});var Oe,wt=e(()=>{Oe=[{match:/#.*/g,sub:"todo"},{type:"str",match:/(["'])(\\[^]|(?!\1)[^])*\1?/g},{expand:"num"},{type:"kwd",match:/\b(any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while|not|and|or|xor)\b/g},{type:"oper",match:/[-+*/%~!&<>|=?,]+/g},{type:"func",match:/[a-z_]+(?=\s*\()/g}];});var Ut={};a(Ut,{default:()=>xe});var xe,Pt=e(()=>{xe=[{expand:"strDouble"}];});var Ft={};a(Ft,{default:()=>Le});var Le,Mt=e(()=>{Le=[{match:/#.*/g,sub:"todo"},{match:/("""|''')(\\[^]|(?!\1)[^])*\1?/g,sub:"todo"},{type:"str",match:/f("|')(\\[^]|(?!\1).)*\1?|f((["'])\4\4)(\\[^]|(?!\3)[^])*\3?/gi,sub:[{type:"var",match:/{[^{}]*}/g,sub:[{match:/(?!^{)[^]*(?=}$)/g,sub:"py"}]}]},{expand:"str"},{type:"kwd",match:/\b(and|as|assert|break|class|continue|def|del|elif|else|except|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|raise|return|try|while|with|yield)\b/g},{type:"bool",match:/\b(False|True|None)\b/g},{expand:"num"},{type:"func",match:/[a-z_]+(?=\s*\()/g},{type:"oper",match:/[-/*+<>,=!&|^%]+/g},{type:"class",match:/\b[A-Z][\w_]*\b/g}];});var $t={};a($t,{default:()=>Se,type:()=>Ce});var Se,Ce,vt=e(()=>{Se=[{match:/^(?!\/).*/gm,sub:"todo"},{type:"num",match:/\[((?!\])[^\\]|\\.)*\]/g},{type:"kwd",match:/\||\^|\$|\\.|\w+($|\r|\n)/g},{type:"var",match:/\*|\+|\{\d+,\d+\}/g}],Ce="oper";});var Bt={};a(Bt,{default:()=>De});var De,Gt=e(()=>{De=[{match:/\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,sub:"todo"},{expand:"str"},{expand:"num"},{type:"kwd",match:/\b(as|break|const|continue|crate|else|enum|extern|false|fn|for|if|impl|in|let|loop|match|mod|move|mut|pub|ref|return|self|Self|static|struct|super|trait|true|type|unsafe|use|where|while|async|await|dyn|abstract|become|box|do|final|macro|override|priv|typeof|unsized|virtual|yield|try)\b/g},{type:"oper",match:/[/*+:?&|%^~=!,<>.^-]+/g},{type:"class",match:/\b[A-Z][\w_]*\b/g},{type:"func",match:/[a-zA-Z_][\w_]*(?=\s*!?\s*\()/g}];});var kt={};a(kt,{default:()=>we});var we,Ht=e(()=>{we=[{match:/--.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,sub:"todo"},{expand:"str"},{type:"func",match:/\b(AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/g},{type:"kwd",match:/\b(ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|kwdS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:S|ING)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/g},{type:"num",match:/\.?\d[\d.oxa-fA-F-]*|\bNULL\b/g},{type:"bool",match:/\b(TRUE|FALSE)\b/g},{type:"oper",match:/[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|IN|ILIKE|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/g},{type:"var",match:/@\S+/g}];});var zt={};a(zt,{default:()=>Ue});var Ue,_t=e(()=>{Ue=[{match:/#.*/g,sub:"todo"},{type:"str",match:/("""|''')((?!\1)[^]|\\[^])*\1?/g},{expand:"str"},{type:"section",match:/^\[.+\]\s*$/gm},{type:"num",match:/\b(inf|nan)\b|\d[\d:ZT.-]*/g},{expand:"num"},{type:"bool",match:/\b(true|false)\b/g},{type:"oper",match:/[+,.=-]/g},{type:"var",match:/\w+(?= \=)/g}];});var Yt={};a(Yt,{default:()=>Pe});var Pe,Zt=e(()=>{S();Pe=[{type:"type",match:/:\s*(any|void|number|boolean|string|object|never|enum)\b/g},{type:"kwd",match:/\b(type|namespace|typedef|interface|public|private|protected|implements|declare|abstract|readonly)\b/g},...L];});var Xt={};a(Xt,{default:()=>Fe});var Fe,Wt=e(()=>{Fe=[{match:/^#.*/gm,sub:"todo"},{type:"class",match:/^\w+(?=:?)/gm},{type:"num",match:/:\d+/g},{type:"oper",match:/[:/&?]|\w+=/g},{type:"func",match:/[.\w]+@|#[\w]+$/gm},{type:"var",match:/\w+\.\w+(\.\w+)*/g}];});var jt={};a(jt,{default:()=>Me});var Me,Kt=e(()=>{Me=[{match:/#.*/g,sub:"todo"},{expand:"str"},{type:"str",match:/(>|\|)\r?\n((\s[^\n]*)?(\r?\n|$))*/g},{type:"type",match:/!![a-z]+/g},{type:"bool",match:/\b(Yes|No)\b/g},{type:"oper",match:/[+:-]/g},{expand:"num"},{type:"var",match:/[a-zA-Z]\w*(?=:)/g}];});var Vt={};a(Vt,{default:()=>n});var n,y=e(()=>{n={black:"\x1B[30m",red:"\x1B[31m",green:"\x1B[32m",gray:"\x1B[90m",yellow:"\x1B[33m",blue:"\x1B[34m",magenta:"\x1B[35m",cyan:"\x1B[36m",white:"\x1B[37m"};});var qt={};a(qt,{default:()=>ve});var ve;var M={};a(M,{default:()=>Be});var Be,$=e(()=>{y();Be={deleted:n.red,var:n.red,err:n.red,kwd:n.red,num:n.yellow,class:n.yellow,cmnt:n.gray,insert:n.green,str:n.green,bool:n.cyan,type:n.blue,oper:n.blue,section:n.magenta,func:n.magenta};});var v={num:{type:"num",match:/(\.e?|\b)\d(e-|[\d.oxa-fA-F_])*(\.|\b)/g},str:{type:"str",match:/(["'])(\\[^]|(?!\1)[^\r\n\\])*\1?/g},strDouble:{type:"str",match:/"((?!")[^\r\n\\]|\\[^])*"?/g}};var $e=d({"./languages/asm.js":()=>Promise.resolve().then(()=>(G(),B)),"./languages/bash.js":()=>Promise.resolve().then(()=>(N(),H)),"./languages/bf.js":()=>Promise.resolve().then(()=>(_(),z)),"./languages/c.js":()=>Promise.resolve().then(()=>(Z(),Y)),"./languages/css.js":()=>Promise.resolve().then(()=>(W(),X)),"./languages/csv.js":()=>Promise.resolve().then(()=>(K(),j)),"./languages/diff.js":()=>Promise.resolve().then(()=>(R(),V)),"./languages/docker.js":()=>Promise.resolve().then(()=>(Q(),q)),"./languages/git.js":()=>Promise.resolve().then(()=>(tt(),J)),"./languages/go.js":()=>Promise.resolve().then(()=>(at(),et)),"./languages/html.js":()=>Promise.resolve().then(()=>(rt(),st)),"./languages/http.js":()=>Promise.resolve().then(()=>(mt(),ct)),"./languages/ini.js":()=>Promise.resolve().then(()=>(lt(),ot)),"./languages/java.js":()=>Promise.resolve().then(()=>(Et(),ut)),"./languages/js.js":()=>Promise.resolve().then(()=>(S(),it)),"./languages/js_template_literals.js":()=>Promise.resolve().then(()=>(gt(),ht)),"./languages/jsdoc.js":()=>Promise.resolve().then(()=>(yt(),bt)),"./languages/json.js":()=>Promise.resolve().then(()=>(ft(),Tt)),"./languages/leanpub-md.js":()=>Promise.resolve().then(()=>(At(),Nt)),"./languages/log.js":()=>Promise.resolve().then(()=>(Ot(),Rt)),"./languages/lua.js":()=>Promise.resolve().then(()=>(Lt(),xt)),"./languages/make.js":()=>Promise.resolve().then(()=>(Ct(),St)),"./languages/md.js":()=>Promise.resolve().then(()=>(U(),It)),"./languages/pl.js":()=>Promise.resolve().then(()=>(wt(),Dt)),"./languages/plain.js":()=>Promise.resolve().then(()=>(Pt(),Ut)),"./languages/py.js":()=>Promise.resolve().then(()=>(Mt(),Ft)),"./languages/regex.js":()=>Promise.resolve().then(()=>(vt(),$t)),"./languages/rs.js":()=>Promise.resolve().then(()=>(Gt(),Bt)),"./languages/sql.js":()=>Promise.resolve().then(()=>(Ht(),kt)),"./languages/todo.js":()=>Promise.resolve().then(()=>(D(),dt)),"./languages/toml.js":()=>Promise.resolve().then(()=>(_t(),zt)),"./languages/ts.js":()=>Promise.resolve().then(()=>(Zt(),Yt)),"./languages/uri.js":()=>Promise.resolve().then(()=>(Wt(),Xt)),"./languages/xml.js":()=>Promise.resolve().then(()=>(x(),nt)),"./languages/yaml.js":()=>Promise.resolve().then(()=>(Kt(),jt))});var P={};async function F(p,t,s){try{let r,m,c={},T,o=[],h=0,f=typeof t=="string"?await(P[t]??(P[t]=$e(`./languages/${t}.js`))):t,g=[...typeof t=="string"?f.default:t.sub];for(;h<p.length;){for(c.index=null,r=g.length;r-- >0;){if(m=g[r].expand?v[g[r].expand]:g[r],o[r]===void 0||o[r].match.index<h){if(m.match.lastIndex=h,T=m.match.exec(p),T===null){g.splice(r,1),o.splice(r,1);continue}o[r]={match:T,lastIndex:m.match.lastIndex};}o[r].match[0]&&(o[r].match.index<=c.index||c.index===null)&&(c={part:m,index:o[r].match.index,match:o[r].match[0],end:o[r].lastIndex});}if(c.index===null)break;s(p.slice(h,c.index),f.type),h=c.end,c.part.sub?await F(c.match,typeof c.part.sub=="string"?c.part.sub:typeof c.part.sub=="function"?c.part.sub(c.match):c.part,s):s(c.match,c.part.type);}s(p.slice(h,p.length),f.type);}catch{s(p);}}var Jt=Promise.resolve().then(()=>($(),M)),ke=async(p,t)=>{let s="",r=(await Jt).default;return await F(p,t,(m,c)=>s+=c?`${r[c]??""}${m}\x1B[0m`:m),s};

var GUTTER = "\u2503";
var POINTER = "\u276F";
var LANGS_MAP = {
  ".tsx": "ts",
  ".jsx": "js",
  ".js": "js",
  ".ts": "ts",
  ".css": "css",
  ".json": "json",
  ".html": "html",
  ".astro": "ts",
  ".vue": "ts"
};
var ErrorStackSource = class extends BaseComponent {
  cssFile = new URL("./error_stack_source/style.css", publicDirURL);
  /**
   * The toHTML method is used to output the HTML for the
   * web view
   */
  async toHTML(props) {
    const frame = props.frame;
    if (frame.type === "native" || !frame.source || !frame.fileName) {
      return "";
    }
    const language = LANGS_MAP[extname(frame.fileName)] ?? "plain";
    const highlightMarginTop = `${frame.source.findIndex((chunk) => {
      return chunk.lineNumber === frame.lineNumber;
    }) * 24}px`;
    const highlight = `<div class="line-highlight" style="margin-top: ${highlightMarginTop}"></div>`;
    let code = await we$1(
      frame.source.map((chunk) => chunk.chunk).join("\n"),
      language,
      true
    );
    code = code.replace(
      '<div class="shj-numbers">',
      `<div class="shj-numbers" style="counter-set: line ${frame.source[0].lineNumber - 1}">`
    );
    return `<pre><code class="shj-lang-js">${highlight}${code}</code></pre>`;
  }
  /**
   * The toANSI method is used to output the text for the console
   */
  async toANSI(props) {
    const frame = props.frame;
    if (frame.type === "native" || !frame.source || !frame.fileName) {
      return "";
    }
    const language = LANGS_MAP[extname(frame.fileName)] ?? "plain";
    const largestLineNumber = Math.max(...frame.source.map(({ lineNumber }) => lineNumber));
    const lineNumberCols = String(largestLineNumber).length;
    const code = frame.source.map(({ chunk }) => chunk).join("\n");
    const highlighted = await ke(code, language);
    return `

${highlighted.split("\n").map((line, index) => {
      const lineNumber = frame.source[index].lineNumber;
      const alignedLineNumber = String(lineNumber).padStart(lineNumberCols, " ");
      if (lineNumber === props.frame.lineNumber) {
        return ` ${colors$1.bgRed(`${POINTER} ${alignedLineNumber} ${GUTTER}  ${stripAnsi(line)}`)}`;
      }
      return `   ${colors$1.dim(alignedLineNumber)} ${colors$1.dim(GUTTER)}  ${line}`;
    }).join("\n")}
`;
  }
};

// src/templates/header/main.ts
var DARK_MODE_SVG = `<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" width="15" height="15" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M0 0h24v24H0z" stroke="none"/><path d="M12 3h.393a7.5 7.5 0 0 0 7.92 12.446A9 9 0 1 1 12 2.992z"/></svg>`;
var LIGHT_MODE_SVG = `<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" width="15" height="15" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M0 0h24v24H0z" stroke="none"/><circle cx="12" cy="12" r="4"/><path d="M3 12h1m8-9v1m8 8h1m-9 8v1M5.6 5.6l.7.7m12.1-.7-.7.7m0 11.4.7.7m-12.1-.7-.7.7"/></svg>`;
var Header = class extends BaseComponent {
  cssFile = new URL("./header/style.css", publicDirURL);
  scriptFile = new URL("./header/script.js", publicDirURL);
  /**
   * The toHTML method is used to output the HTML for the
   * web view
   */
  async toHTML() {
    return `<header id="header">
      <div id="header-actions">
        <div id="toggle-theme-container">
          <input type="checkbox" id="toggle-theme-checkbox" />
          <label id="toggle-theme-label" for="toggle-theme-checkbox">
            <span id="light-theme-indicator" title="Light mode">${LIGHT_MODE_SVG}</span>
            <span id="dark-theme-indicator" title="Dark mode">${DARK_MODE_SVG}</span>
          </label>
        </div>
      </div>
    </header>`;
  }
  /**
   * The toANSI method is used to output the text for the console
   */
  async toANSI() {
    return "";
  }
};

var dist = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	Object.defineProperty(dist, "__esModule", { value: true });
	dist.parse = parse;
	dist.serialize = serialize;
	/**
	 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
	 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
	 * which has been replaced by the token definition in RFC 7230 appendix B.
	 *
	 * cookie-name       = token
	 * token             = 1*tchar
	 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
	 *                     "*" / "+" / "-" / "." / "^" / "_" /
	 *                     "`" / "|" / "~" / DIGIT / ALPHA
	 *
	 * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191
	 * Allow same range as cookie value, except `=`, which delimits end of name.
	 */
	const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
	/**
	 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
	 *
	 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	 *                     ; US-ASCII characters excluding CTLs,
	 *                     ; whitespace DQUOTE, comma, semicolon,
	 *                     ; and backslash
	 *
	 * Allowing more characters: https://github.com/jshttp/cookie/issues/191
	 * Comma, backslash, and DQUOTE are not part of the parsing algorithm.
	 */
	const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
	/**
	 * RegExp to match domain-value in RFC 6265 sec 4.1.1
	 *
	 * domain-value      = <subdomain>
	 *                     ; defined in [RFC1034], Section 3.5, as
	 *                     ; enhanced by [RFC1123], Section 2.1
	 * <subdomain>       = <label> | <subdomain> "." <label>
	 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
	 *                     Labels must be 63 characters or less.
	 *                     'let-dig' not 'letter' in the first char, per RFC1123
	 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
	 * <let-dig-hyp>     = <let-dig> | "-"
	 * <let-dig>         = <letter> | <digit>
	 * <letter>          = any one of the 52 alphabetic characters A through Z in
	 *                     upper case and a through z in lower case
	 * <digit>           = any one of the ten digits 0 through 9
	 *
	 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
	 *
	 * > (Note that a leading %x2E ("."), if present, is ignored even though that
	 * character is not permitted, but a trailing %x2E ("."), if present, will
	 * cause the user agent to ignore the attribute.)
	 */
	const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
	/**
	 * RegExp to match path-value in RFC 6265 sec 4.1.1
	 *
	 * path-value        = <any CHAR except CTLs or ";">
	 * CHAR              = %x01-7F
	 *                     ; defined in RFC 5234 appendix B.1
	 */
	const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
	const __toString = Object.prototype.toString;
	const NullObject = /* @__PURE__ */ (() => {
	    const C = function () { };
	    C.prototype = Object.create(null);
	    return C;
	})();
	/**
	 * Parse a cookie header.
	 *
	 * Parse the given cookie header string into an object
	 * The object has the various cookies as keys(names) => values
	 */
	function parse(str, options) {
	    const obj = new NullObject();
	    const len = str.length;
	    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
	    if (len < 2)
	        return obj;
	    const dec = options?.decode || decode;
	    let index = 0;
	    do {
	        const eqIdx = str.indexOf("=", index);
	        if (eqIdx === -1)
	            break; // No more cookie pairs.
	        const colonIdx = str.indexOf(";", index);
	        const endIdx = colonIdx === -1 ? len : colonIdx;
	        if (eqIdx > endIdx) {
	            // backtrack on prior semicolon
	            index = str.lastIndexOf(";", eqIdx - 1) + 1;
	            continue;
	        }
	        const keyStartIdx = startIndex(str, index, eqIdx);
	        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
	        const key = str.slice(keyStartIdx, keyEndIdx);
	        // only assign once
	        if (obj[key] === undefined) {
	            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
	            let valEndIdx = endIndex(str, endIdx, valStartIdx);
	            const value = dec(str.slice(valStartIdx, valEndIdx));
	            obj[key] = value;
	        }
	        index = endIdx + 1;
	    } while (index < len);
	    return obj;
	}
	function startIndex(str, index, max) {
	    do {
	        const code = str.charCodeAt(index);
	        if (code !== 0x20 /*   */ && code !== 0x09 /* \t */)
	            return index;
	    } while (++index < max);
	    return max;
	}
	function endIndex(str, index, min) {
	    while (index > min) {
	        const code = str.charCodeAt(--index);
	        if (code !== 0x20 /*   */ && code !== 0x09 /* \t */)
	            return index + 1;
	    }
	    return min;
	}
	/**
	 * Serialize data into a cookie header.
	 *
	 * Serialize a name value pair into a cookie string suitable for
	 * http headers. An optional options object specifies cookie parameters.
	 *
	 * serialize('foo', 'bar', { httpOnly: true })
	 *   => "foo=bar; httpOnly"
	 */
	function serialize(name, val, options) {
	    const enc = options?.encode || encodeURIComponent;
	    if (!cookieNameRegExp.test(name)) {
	        throw new TypeError(`argument name is invalid: ${name}`);
	    }
	    const value = enc(val);
	    if (!cookieValueRegExp.test(value)) {
	        throw new TypeError(`argument val is invalid: ${val}`);
	    }
	    let str = name + "=" + value;
	    if (!options)
	        return str;
	    if (options.maxAge !== undefined) {
	        if (!Number.isInteger(options.maxAge)) {
	            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
	        }
	        str += "; Max-Age=" + options.maxAge;
	    }
	    if (options.domain) {
	        if (!domainValueRegExp.test(options.domain)) {
	            throw new TypeError(`option domain is invalid: ${options.domain}`);
	        }
	        str += "; Domain=" + options.domain;
	    }
	    if (options.path) {
	        if (!pathValueRegExp.test(options.path)) {
	            throw new TypeError(`option path is invalid: ${options.path}`);
	        }
	        str += "; Path=" + options.path;
	    }
	    if (options.expires) {
	        if (!isDate(options.expires) ||
	            !Number.isFinite(options.expires.valueOf())) {
	            throw new TypeError(`option expires is invalid: ${options.expires}`);
	        }
	        str += "; Expires=" + options.expires.toUTCString();
	    }
	    if (options.httpOnly) {
	        str += "; HttpOnly";
	    }
	    if (options.secure) {
	        str += "; Secure";
	    }
	    if (options.partitioned) {
	        str += "; Partitioned";
	    }
	    if (options.priority) {
	        const priority = typeof options.priority === "string"
	            ? options.priority.toLowerCase()
	            : undefined;
	        switch (priority) {
	            case "low":
	                str += "; Priority=Low";
	                break;
	            case "medium":
	                str += "; Priority=Medium";
	                break;
	            case "high":
	                str += "; Priority=High";
	                break;
	            default:
	                throw new TypeError(`option priority is invalid: ${options.priority}`);
	        }
	    }
	    if (options.sameSite) {
	        const sameSite = typeof options.sameSite === "string"
	            ? options.sameSite.toLowerCase()
	            : options.sameSite;
	        switch (sameSite) {
	            case true:
	            case "strict":
	                str += "; SameSite=Strict";
	                break;
	            case "lax":
	                str += "; SameSite=Lax";
	                break;
	            case "none":
	                str += "; SameSite=None";
	                break;
	            default:
	                throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
	        }
	    }
	    return str;
	}
	/**
	 * URL-decode string value. Optimized to skip native call when no %.
	 */
	function decode(str) {
	    if (str.indexOf("%") === -1)
	        return str;
	    try {
	        return decodeURIComponent(str);
	    }
	    catch (e) {
	        return str;
	    }
	}
	/**
	 * Determine if value is a Date.
	 */
	function isDate(val) {
	    return __toString.call(val) === "[object Date]";
	}
	
	return dist;
}

var distExports = requireDist();
const cookie = /*@__PURE__*/getDefaultExportFromCjs(distExports);

// src/exception.ts
var Exception = class extends Error {
  /**
   * Name of the class that raised the exception.
   */
  name;
  /**
   * A status code for the error. Usually helpful when converting errors
   * to HTTP responses.
   */
  status;
  constructor(message, options) {
    super(message, options);
    const ErrorConstructor = this.constructor;
    this.name = ErrorConstructor.name;
    this.message = message || ErrorConstructor.message || "";
    this.status = options?.status || ErrorConstructor.status || 500;
    const code = options?.code || ErrorConstructor.code;
    if (code !== void 0) {
      this.code = code;
    }
    const help = ErrorConstructor.help;
    if (help !== void 0) {
      this.help = help;
    }
    Error.captureStackTrace(this, ErrorConstructor);
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    if (this.code) {
      return `${this.name} [${this.code}]: ${this.message}`;
    }
    return `${this.name}: ${this.message}`;
  }
};

const FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
const CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
const SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;
function parse$1(error, options) {
  if (typeof error.stacktrace !== "undefined" || typeof error["opera#sourceloc"] !== "undefined")
    return parseOpera(error, options);
  else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP))
    return parseV8OrIE(error, options);
  else if (error.stack)
    return parseFFOrSafari(error, options);
  else if (options?.allowEmpty)
    return [];
  else
    throw new Error("Cannot parse given Error object");
}
function extractLocation(urlLike) {
  if (!urlLike.includes(":"))
    return [urlLike, undefined, undefined];
  const regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
  const parts = regExp.exec(urlLike.replace(/[()]/g, ""));
  return [parts[1], parts[2] || undefined, parts[3] || undefined];
}
function applySlice(lines, options) {
  if (options && options.slice != null) {
    if (Array.isArray(options.slice))
      return lines.slice(options.slice[0], options.slice[1]);
    return lines.slice(0, options.slice);
  }
  return lines;
}
function parseV8OrIE(error, options) {
  return parseV8OrIeString(error.stack, options);
}
function parseV8OrIeString(stack, options) {
  const filtered = applySlice(
    stack.split("\n").filter((line) => {
      return !!line.match(CHROME_IE_STACK_REGEXP);
    }),
    options
  );
  return filtered.map((line) => {
    if (line.includes("(eval ")) {
      line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
    }
    let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
    const location = sanitizedLine.match(/ (\(.+\)$)/);
    sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
    const locationParts = extractLocation(location ? location[1] : sanitizedLine);
    const functionName = location && sanitizedLine || undefined;
    const fileName = ["eval", "<anonymous>"].includes(locationParts[0]) ? undefined : locationParts[0];
    return {
      function: functionName,
      file: fileName,
      line: locationParts[1] ? +locationParts[1] : undefined,
      col: locationParts[2] ? +locationParts[2] : undefined,
      raw: line
    };
  });
}
function parseFFOrSafari(error, options) {
  return parseFFOrSafariString(error.stack, options);
}
function parseFFOrSafariString(stack, options) {
  const filtered = applySlice(
    stack.split("\n").filter((line) => {
      return !line.match(SAFARI_NATIVE_CODE_REGEXP);
    }),
    options
  );
  return filtered.map((line) => {
    if (line.includes(" > eval"))
      line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
    if (!line.includes("@") && !line.includes(":")) {
      return {
        function: line
      };
    } else {
      const functionNameRegex = /(([^\n\r"\u2028\u2029]*".[^\n\r"\u2028\u2029]*"[^\n\r@\u2028\u2029]*(?:@[^\n\r"\u2028\u2029]*"[^\n\r@\u2028\u2029]*)*(?:[\n\r\u2028\u2029][^@]*)?)?[^@]*)@/;
      const matches = line.match(functionNameRegex);
      const functionName = matches && matches[1] ? matches[1] : undefined;
      const locationParts = extractLocation(line.replace(functionNameRegex, ""));
      return {
        function: functionName,
        file: locationParts[0],
        line: locationParts[1] ? +locationParts[1] : undefined,
        col: locationParts[2] ? +locationParts[2] : undefined,
        raw: line
      };
    }
  });
}
function parseOpera(e, options) {
  if (!e.stacktrace || e.message.includes("\n") && e.message.split("\n").length > e.stacktrace.split("\n").length)
    return parseOpera9(e);
  else if (!e.stack)
    return parseOpera10(e);
  else
    return parseOpera11(e, options);
}
function parseOpera9(e, options) {
  const lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
  const lines = e.message.split("\n");
  const result = [];
  for (let i = 2, len = lines.length; i < len; i += 2) {
    const match = lineRE.exec(lines[i]);
    if (match) {
      result.push({
        file: match[2],
        line: +match[1],
        raw: lines[i]
      });
    }
  }
  return applySlice(result, options);
}
function parseOpera10(e, options) {
  const lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
  const lines = e.stacktrace.split("\n");
  const result = [];
  for (let i = 0, len = lines.length; i < len; i += 2) {
    const match = lineRE.exec(lines[i]);
    if (match) {
      result.push({
        function: match[3] || undefined,
        file: match[2],
        line: match[1] ? +match[1] : undefined,
        raw: lines[i]
      });
    }
  }
  return applySlice(result, options);
}
function parseOpera11(error, options) {
  const filtered = applySlice(
    // @ts-expect-error missing stack property
    error.stack.split("\n").filter((line) => {
      return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
    }),
    options
  );
  return filtered.map((line) => {
    const tokens = line.split("@");
    const locationParts = extractLocation(tokens.pop());
    const functionCall = tokens.shift() || "";
    const functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || undefined;
    let argsRaw;
    if (functionCall.match(/\(([^)]*)\)/))
      argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, "$1");
    const args = argsRaw === undefined || argsRaw === "[arguments not available]" ? undefined : argsRaw.split(",");
    return {
      function: functionName,
      args,
      file: locationParts[0],
      line: locationParts[1] ? +locationParts[1] : undefined,
      col: locationParts[2] ? +locationParts[2] : undefined,
      raw: line
    };
  });
}

function stackframesLiteToStackframes(liteStackframes) {
  return liteStackframes.map((liteStackframe) => {
    return {
      functionName: liteStackframe.function,
      args: liteStackframe.args,
      fileName: liteStackframe.file,
      lineNumber: liteStackframe.line,
      columnNumber: liteStackframe.col,
      source: liteStackframe.raw
    };
  });
}
function parse(error, options) {
  return stackframesLiteToStackframes(parse$1(error, options));
}

// src/parser.ts
var debug_default = debuglog("youch:core");

// src/source_file.ts
var SourceFile = class {
  #contents;
  constructor(options) {
    if ("contents" in options) {
      this.#contents = options.contents;
    }
  }
  /**
   * Slice the file contents for the buffer size around a given
   * line number.
   *
   * @example
   * ```ts
   * const chunks = sourceFile.slice(11, 7)
   * // Here chunks will be an array of 7 items from line number
   * // 8 to 14
   * ```
   */
  slice(lineNumber, bufferSize) {
    if (!this.#contents) {
      return void 0;
    }
    const lines = this.#contents.split(/\n|\r\n/);
    const contentSize = lines.length;
    const chunkSize = Math.ceil((bufferSize - 1) / 2);
    let startIndex = chunkSize >= lineNumber ? 0 : lineNumber - chunkSize - 1;
    if (contentSize - lineNumber < chunkSize) {
      startIndex = Math.max(startIndex - (chunkSize - (contentSize - lineNumber)), 0);
    }
    const sourceIndex = lineNumber - 1;
    const startRemainder = startIndex - sourceIndex + chunkSize;
    const endIndex = startRemainder + chunkSize + lineNumber;
    debug_default("slicing file contents", {
      startIndex,
      endIndex,
      sourceIndex,
      contentSize,
      bufferSize,
      chunkSize
    });
    return lines.slice(startIndex, endIndex).map((chunk, index) => {
      return {
        chunk,
        lineNumber: startIndex + index + 1
      };
    });
  }
};

// src/parser.ts
var ErrorParser = class _ErrorParser {
  /**
   * FS source loader reads the file contents from the filesystem
   * for all non-native frames
   */
  static fsSourceLoader = async (frame) => {
    if (!frame.fileName || frame.fileType !== "fs" || frame.type === "native") {
      return void 0;
    }
    debug_default("reading contents for source file %s", frame.fileName);
    try {
      return {
        contents: await readFile(frame.fileName, "utf-8")
      };
    } catch (error) {
      debug_default(`Unable to read source file %s, error %s`, frame.fileName, error.message);
    }
  };
  /**
   * Native frames filename identifiers for Node.js and
   * Deno
   */
  #nativeFramesIdentifiers = ["node:", "ext:"];
  /**
   * Native frames filename identifier for Bun. In case of
   * bun, the filename exactly matches the keyword "native"
   */
  #bunNativeIdentifier = "native";
  /**
   * Cache of preloaded source files along with their absolute
   * path
   */
  #sourceFiles = /* @__PURE__ */ new Map();
  /**
   * The offset can be used to skip initial frames from the
   * error stack
   */
  #offset;
  /**
   * Custom source loader to consult for reading the sourcefile
   * contents
   */
  #sourceLoader = _ErrorParser.fsSourceLoader;
  /**
   * Parsers are used to prepare the source value for parsing
   */
  #parsers = [];
  /**
   * Transformers are used to post process the parsed error and
   * attach additional information to it.
   */
  #transformers = [];
  constructor(options) {
    options = options ?? {};
    this.#offset = options.offset;
  }
  /**
   * Normalizes the unknown error to be an Error
   */
  #normalizeError(source) {
    if (source instanceof Error) {
      return source;
    }
    if (typeof source === "object" && source && "message" in source && "stack" in source) {
      return source;
    }
    const error = new Exception(JSON.stringify(source));
    error.help = 'To get as much information as possible from your errors, make sure to throw Error objects. See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error</a> for more information.';
    return error;
  }
  /**
   * Returns the source chunks for a given file and the
   * line number.
   */
  async #getSource(frame) {
    let sourceFile = this.#sourceFiles.get(frame.fileName);
    if (sourceFile) {
      debug_default("reading sourcefile from cache %s", frame.fileName);
      return sourceFile.slice(frame.lineNumber ?? 1, 11);
    }
    const contents = await this.#sourceLoader(frame);
    if (contents) {
      sourceFile = new SourceFile(contents);
      debug_default("caching sourcefile instance for %s", frame.fileName);
      this.#sourceFiles.set(frame.fileName, sourceFile);
      return sourceFile.slice(frame.lineNumber ?? 1, 11);
    }
  }
  /**
   * Syntax errors in JavaScript does not contain the source file
   * location within the stack trace, since the error has
   * happened in the language parser.
   *
   * However, Node.js includes the absolute path to the file within
   * the stack trace contents as the first line. So we parse
   * that out in this function.
   */
  #parseSyntaxError(error) {
    const [sourceIdentifier] = error.stack?.split("\n") || [];
    const tokens = sourceIdentifier.split(":");
    const lineNumber = Number(tokens.pop());
    const fileName = tokens.join(":");
    if (fileName && !Number.isNaN(lineNumber)) {
      return [
        {
          fileName,
          lineNumber,
          source: sourceIdentifier
        }
      ];
    }
    return [];
  }
  /**
   * Applies the offset on the frames to skip certain frames
   * from the start
   */
  #applyOffset(frames) {
    if (this.#offset) {
      return frames.slice(this.#offset);
    }
    return frames;
  }
  /**
   * Replaces windows slash to unix slash
   */
  #toUnixSlash(fileName) {
    const isExtendedLengthPath = fileName.startsWith("\\\\?\\");
    return isExtendedLengthPath ? fileName : fileName.replace(/\\/g, "/");
  }
  /**
   * Normalizes the filename to be a path with unix slash. The
   * URL style paths are also converted to normalized file
   * paths
   */
  #normalizeFileName(fileName) {
    if (fileName.startsWith("file:")) {
      return this.#toUnixSlash(fileURLToPath(fileName));
    }
    return this.#toUnixSlash(fileName);
  }
  /**
   * Returns the type of the frame.
   */
  #getFrameType(fileName) {
    return this.#nativeFramesIdentifiers.some((identifier) => fileName.includes(identifier)) || fileName === this.#bunNativeIdentifier ? "native" : fileName.includes("node_modules/") ? "module" : "app";
  }
  /**
   * Returns the source type of the frame.
   */
  #getFrameSourceType(fileName) {
    return fileName.startsWith("http://") ? "http" : fileName.startsWith("https://") ? "https" : "fs";
  }
  /**
   * Enhances a frame to contain additional information
   */
  async #enhanceFrames(frames) {
    let stackFrames = [];
    for (const { source: raw, ...frame } of frames) {
      const stackFrame = {
        ...frame,
        raw
      };
      if (!stackFrame.fileName) {
        stackFrames.push(stackFrame);
        continue;
      }
      stackFrame.fileName = this.#normalizeFileName(stackFrame.fileName);
      stackFrame.type = this.#getFrameType(stackFrame.fileName);
      stackFrame.fileType = this.#getFrameSourceType(stackFrame.fileName);
      stackFrame.source = await this.#getSource(stackFrame);
      debug_default("stack frame %O", stackFrame);
      stackFrames.push(stackFrame);
    }
    return stackFrames;
  }
  /**
   * Register a parser. Parsers are synchronous functions
   * that can be used to pre-process the source value
   * before it get parsed.
   *
   * @example
   * ```ts
   * sourceFile.useParser((source) => {
   *   if (valueCanBeParsed) {
   *     return newValue
   *   }
   *   return source
   * })
   * ```
   */
  useParser(parser) {
    this.#parsers.push(parser);
    return this;
  }
  /**
   * Register a transformer. Transformers can be async functions
   * to post-process the parsed error value.
   *
   * @example
   * ```ts
   * sourceFile.useTransformer((error, source) => {
   *   // mutate "error" properties
   * })
   * ```
   */
  useTransformer(transformer) {
    this.#transformers.push(transformer);
    return this;
  }
  /**
   * Define a custom source loader to load the contents of the
   * source file within the error stack.
   *
   * For example: You might want to register a custom source loader
   * that makes an fetch call to the server to read the source of
   * the file within the error stack.
   */
  defineSourceLoader(loader) {
    this.#sourceLoader = loader;
    return this;
  }
  /**
   * Parse an unknown value into a parsed error object.
   */
  async parse(source) {
    debug_default("parsing source %O", source);
    source = this.#parsers.reduce((result, parser) => {
      result = parser(result);
      return result;
    }, source);
    let error = this.#normalizeError(source);
    debug_default("error normalized to %O", error);
    let esFrames = error instanceof SyntaxError ? this.#parseSyntaxError(error) : [];
    esFrames = esFrames.concat(parse(error, { allowEmpty: true }));
    esFrames = this.#applyOffset(esFrames);
    const parsedError = {
      message: error.message,
      name: error.name,
      frames: await this.#enhanceFrames(esFrames),
      hint: "hint" in error && error.hint ? String(error.hint) : "help" in error && error.help ? String(error.help) : void 0,
      code: "code" in error ? String(error.code) : void 0,
      cause: error.cause,
      stack: error.stack,
      raw: error
    };
    for (const transformer of this.#transformers) {
      await transformer(parsedError, error);
    }
    return parsedError;
  }
};

// src/metadata.ts
var Metadata = class {
  #groups = {};
  /**
   * Converts value to an array (if not an array already)
   */
  #toArray(value) {
    return Array.isArray(value) ? value : [value];
  }
  /**
   * Define a group, its sections and their rows. In case of
   * existing groups/sections, the new data will be merged
   * with the existing data
   */
  group(name, sections) {
    this.#groups[name] = this.#groups[name] ?? {};
    Object.keys(sections).forEach((section) => {
      if (!this.#groups[name][section]) {
        this.#groups[name][section] = sections[section];
      } else {
        this.#groups[name][section] = this.#toArray(this.#groups[name][section]);
        this.#groups[name][section].push(...this.#toArray(sections[section]));
      }
    });
    return this;
  }
  /**
   * Returns the existing metadata groups, sections and
   * rows.
   */
  toJSON() {
    return this.#groups;
  }
};
var Templates = class {
  constructor(devMode) {
    this.devMode = devMode;
    this.#knownTemplates = {
      layout: new Layout(devMode),
      header: new Header(devMode),
      errorInfo: new ErrorInfo(devMode),
      errorStack: new ErrorStack(devMode),
      errorStackSource: new ErrorStackSource(devMode),
      errorCause: new ErrorCause(devMode),
      errorMetadata: new ErrorMetadata(devMode)
    };
  }
  #knownTemplates;
  #styles = /* @__PURE__ */ new Map([["global", createStyleSheet()]]);
  #scripts = /* @__PURE__ */ new Map([["global", createScript()]]);
  /**
   * Returns a collection of style and script tags to dump
   * inside the document HEAD.
   */
  #getStylesAndScripts(cspNonce) {
    let customInjectedStyles = "";
    const styles = [];
    const scripts = [];
    const cspNonceAttr = cspNonce ? ` nonce="${cspNonce}"` : "";
    this.#styles.forEach((bucket, name) => {
      if (name === "injected") {
        customInjectedStyles = `<style id="${name}-styles"${cspNonceAttr}>${bucket}</style>`;
      } else {
        styles.push(`<style id="${name}-styles"${cspNonceAttr}>${bucket}</style>`);
      }
    });
    this.#scripts.forEach((bucket, name) => {
      scripts.push(`<script id="${name}-script"${cspNonceAttr}>${bucket}</script>`);
    });
    return { styles: `${styles.join("\n")}
${customInjectedStyles}`, scripts: scripts.join("\n") };
  }
  /**
   * Collects styles and scripts for components as we render
   * them.
   */
  async #collectStylesAndScripts(templateName) {
    if (!this.#styles.has(templateName)) {
      const styles = await this.#knownTemplates[templateName].getStyles();
      if (styles) {
        this.#styles.set(templateName, styles);
      }
    }
    if (!this.#scripts.has(templateName)) {
      const script = await this.#knownTemplates[templateName].getScript();
      if (script) {
        this.#scripts.set(templateName, script);
      }
    }
  }
  /**
   * Returns the HTML for a given template
   */
  async #tmplToHTML(templateName, props) {
    const component = this.#knownTemplates[templateName];
    if (!component) {
      throw new Error(`Invalid template "${templateName}"`);
    }
    await this.#collectStylesAndScripts(templateName);
    return component.toHTML(props);
  }
  /**
   * Returns the ANSI output for a given template
   */
  async #tmplToANSI(templateName, props) {
    const component = this.#knownTemplates[templateName];
    if (!component) {
      throw new Error(`Invalid template "${templateName}"`);
    }
    return component.toANSI(props);
  }
  /**
   * Define a custom component to be used in place of the default component.
   * Overriding components allows you control the HTML layout, styles and
   * the frontend scripts of an HTML fragment.
   */
  use(templateName, component) {
    this.#knownTemplates[templateName] = component;
    return this;
  }
  /**
   * Inject custom styles to the document. Injected styles are
   * always placed after the global and the components style
   * tags.
   */
  injectStyles(cssFragment) {
    let injectedStyles = this.#styles.get("injected") ?? "";
    injectedStyles += `
${cssFragment}`;
    this.#styles.set("injected", injectedStyles);
    return this;
  }
  /**
   * Returns the HTML output for the given parsed error
   */
  async toHTML(props) {
    const html = await this.#tmplToHTML("layout", {
      title: props.title,
      ide: props.ide,
      cspNonce: props.cspNonce,
      children: async () => {
        const header = await this.#tmplToHTML("header", props);
        const info = await this.#tmplToHTML("errorInfo", props);
        const stackTrace = await this.#tmplToHTML("errorStack", {
          ide: process.env.EDITOR ?? "vscode",
          sourceCodeRenderer: (error, frame) => {
            return this.#tmplToHTML("errorStackSource", {
              error,
              frame,
              ide: props.ide,
              cspNonce: props.cspNonce
            });
          },
          ...props
        });
        const cause = await this.#tmplToHTML("errorCause", props);
        const metadata = await this.#tmplToHTML("errorMetadata", props);
        return `${header}${info}${stackTrace}${cause}${metadata}`;
      }
    });
    const { scripts, styles } = this.#getStylesAndScripts(props.cspNonce);
    return html.replace("<!-- STYLES -->", styles).replace("<!-- SCRIPTS -->", scripts);
  }
  /**
   * Returns the ANSI output to be printed on the terminal
   */
  async toANSI(props) {
    const ansiOutput = await this.#tmplToANSI("layout", {
      title: props.title,
      children: async () => {
        const header = await this.#tmplToANSI("header", {});
        const info = await this.#tmplToANSI("errorInfo", props);
        const stackTrace = await this.#tmplToANSI("errorStack", {
          ide: process.env.EDITOR ?? "vscode",
          sourceCodeRenderer: (error, frame) => {
            return this.#tmplToANSI("errorStackSource", {
              error,
              frame
            });
          },
          ...props
        });
        const cause = await this.#tmplToANSI("errorCause", props);
        const metadata = await this.#tmplToANSI("errorMetadata", props);
        return `${header}${info}${stackTrace}${cause}${metadata}`;
      }
    });
    return ansiOutput;
  }
};

// src/youch.ts
var Youch = class {
  /**
   * Properties to be shared with the Error parser
   */
  #sourceLoader;
  #parsers = [];
  #transformers = [];
  /**
   * Manage templates used for converting error to the HTML
   * output
   */
  templates = new Templates(false);
  /**
   * Define metadata to be displayed alongside the error output
   */
  metadata = new Metadata();
  /**
   * Creates an instance of the ErrorParser and applies the
   * source loader, parsers and transformers on it
   */
  #createErrorParser(options) {
    const errorParser = new ErrorParser(options);
    if (this.#sourceLoader) {
      errorParser.defineSourceLoader(this.#sourceLoader);
    }
    this.#parsers.forEach((parser) => errorParser.useParser(parser));
    this.#transformers.forEach((transformer) => errorParser.useTransformer(transformer));
    return errorParser;
  }
  /**
   * Defines the request properties as a metadata group
   */
  #defineRequestMetadataGroup(request) {
    if (!request || Object.keys(request).length === 0) {
      return;
    }
    this.metadata.group("Request", {
      ...request.url ? {
        url: {
          key: "URL",
          value: request.url
        }
      } : {},
      ...request.method ? {
        method: {
          key: "Method",
          value: request.method
        }
      } : {},
      ...request.headers ? {
        headers: Object.keys(request.headers).map((key) => {
          const value = request.headers[key];
          return {
            key,
            value: key === "cookie" ? { ...cookie.parse(value) } : value
          };
        })
      } : {}
    });
  }
  /**
   * Define custom implementation for loading the source code
   * of a stack frame.
   */
  defineSourceLoader(loader) {
    this.#sourceLoader = loader;
    return this;
  }
  /**
   * Define a custom parser. Parsers are executed before the
   * error gets parsed and provides you with an option to
   * modify the error
   */
  useParser(parser) {
    this.#parsers.push(parser);
    return this;
  }
  /**
   * Define a custom transformer. Transformers are executed
   * after the error has been parsed and can mutate the
   * properties of the parsed error.
   */
  useTransformer(transformer) {
    this.#transformers.push(transformer);
    return this;
  }
  /**
   * Parses error to JSON
   */
  async toJSON(error, options) {
    options = { ...options };
    return this.#createErrorParser({ offset: options.offset }).parse(error);
  }
  /**
   * Render error to HTML
   */
  async toHTML(error, options) {
    options = { ...options };
    this.#defineRequestMetadataGroup(options.request);
    const parsedError = await this.#createErrorParser({ offset: options.offset }).parse(error);
    return this.templates.toHTML({
      title: options.title ?? "An error has occurred",
      ide: options.ide ?? process.env.IDE ?? "vscode",
      cspNonce: options.cspNonce,
      error: parsedError,
      metadata: this.metadata
    });
  }
  /**
   * Render error to ANSI output
   */
  async toANSI(error, options) {
    options = { ...options };
    const parsedError = await this.#createErrorParser({ offset: options.offset }).parse(error);
    return this.templates.toANSI({
      title: "",
      error: parsedError,
      metadata: this.metadata
    });
  }
};

async function renderError(req, res, error) {
  const youch = new Youch();
  res.statusCode = 500;
  res.setHeader("Content-Type", "text/html");
  const html = await youch.toHTML(error, {
    request: {
      url: req.url,
      method: req.method,
      headers: req.headers
    }
  });
  res.end(html);
}

const RESTART_RE = /^(?:nuxt\.config\.[a-z0-9]+|\.nuxtignore|\.nuxtrc|\.config\/nuxt(?:\.config)?\.[a-z0-9]+)$/;
class NuxtDevServer extends EventEmitter {
  constructor(options) {
    super();
    this.options = options;
    this.loadDebounced = debounce(this.load);
    let _initResolve;
    const _initPromise = new Promise((resolve2) => {
      _initResolve = resolve2;
    });
    this.once("ready", () => {
      _initResolve();
    });
    this.cwd = options.cwd;
    this.handler = async (req, res) => {
      if (this._loadingError) {
        this._renderError(req, res);
        return;
      }
      await _initPromise;
      if (this._handler) {
        this._handler(req, res);
      } else {
        this._renderLoadingScreen(req, res);
      }
    };
    this.listener = void 0;
  }
  _handler;
  _distWatcher;
  _configWatcher;
  _currentNuxt;
  _loadingMessage;
  _loadingError;
  cwd;
  loadDebounced;
  handler;
  listener;
  _renderError(req, res) {
    renderError(req, res, this._loadingError);
  }
  async _renderLoadingScreen(req, res) {
    res.statusCode = 503;
    res.setHeader("Content-Type", "text/html");
    const loadingTemplate = this.options.loadingTemplate || this._currentNuxt?.options.devServer.loadingTemplate || await resolveLoadingTemplate(this.cwd);
    res.end(
      loadingTemplate({
        loading: this._loadingMessage || "Loading..."
      })
    );
  }
  async init() {
    await this.load();
    this._watchConfig();
  }
  closeWatchers() {
    this._distWatcher?.close();
    this._configWatcher?.();
  }
  async load(reload, reason) {
    try {
      await this._load(reload, reason);
      this._loadingError = void 0;
    } catch (error) {
      console.error(`Cannot ${reload ? "restart" : "start"} nuxt: `, error);
      this._handler = void 0;
      this._loadingError = error;
      this._loadingMessage = "Error while loading Nuxt. Please check console and fix errors.";
      this.emit("loading:error", error);
    }
  }
  async close() {
    if (this._currentNuxt) {
      await this._currentNuxt.close();
    }
  }
  async _load(reload, reason) {
    const action = reload ? "Restarting" : "Starting";
    this._loadingMessage = `${reason ? `${reason}. ` : ""}${action} Nuxt...`;
    this._handler = void 0;
    this.emit("loading", this._loadingMessage);
    if (reload) {
      console.info(this._loadingMessage);
    }
    await this.close();
    const kit = await loadKit(this.options.cwd);
    const devServerDefaults = resolveDevServerDefaults({}, await this.listener.getURLs().then((r) => r.map((r2) => r2.url)));
    this._currentNuxt = await kit.loadNuxt({
      cwd: this.options.cwd,
      dev: true,
      ready: false,
      envName: this.options.envName,
      dotenv: {
        cwd: this.options.cwd,
        fileName: this.options.dotenv.fileName
      },
      defaults: defu(this.options.defaults, devServerDefaults),
      overrides: {
        logLevel: this.options.logLevel,
        ...this.options.overrides,
        vite: {
          clearScreen: this.options.clear,
          ...this.options.overrides.vite
        }
      }
    });
    if (!process$1.env.NUXI_DISABLE_VITE_HMR) {
      this._currentNuxt.hooks.hook("vite:extend", ({ config }) => {
        if (config.server) {
          config.server.hmr = {
            protocol: void 0,
            ...config.server.hmr,
            port: void 0,
            host: void 0,
            server: this.listener.server
          };
        }
      });
    }
    this._currentNuxt.hooks.hookOnce("close", () => {
      this.listener.server.removeAllListeners("upgrade");
    });
    if (!reload) {
      const previousManifest = await loadNuxtManifest(this._currentNuxt.options.buildDir);
      const newManifest = resolveNuxtManifest(this._currentNuxt);
      const promise = writeNuxtManifest(this._currentNuxt, newManifest);
      this._currentNuxt.hooks.hookOnce("ready", async () => {
        await promise;
      });
      if (previousManifest && newManifest && previousManifest._hash !== newManifest._hash) {
        await clearBuildDir(this._currentNuxt.options.buildDir);
      }
    }
    await this._currentNuxt.ready();
    const unsub = this._currentNuxt.hooks.hook("restart", async (options) => {
      unsub();
      if (options?.hard) {
        this.emit("restart");
        return;
      }
      await this.load(true);
    });
    if (this._currentNuxt.server && "upgrade" in this._currentNuxt.server) {
      this.listener.server.on("upgrade", (req, socket, head) => {
        const nuxt = this._currentNuxt;
        if (!nuxt || !nuxt.server)
          return;
        const viteHmrPath = joinURL(
          nuxt.options.app.baseURL.startsWith("./") ? nuxt.options.app.baseURL.slice(1) : nuxt.options.app.baseURL,
          nuxt.options.app.buildAssetsDir
        );
        if (req.url?.startsWith(viteHmrPath)) {
          return;
        }
        nuxt.server.upgrade(req, socket, head);
      });
    }
    await this._currentNuxt.hooks.callHook("listen", this.listener.server, this.listener);
    const addr = this.listener.address;
    this._currentNuxt.options.devServer.host = addr.address;
    this._currentNuxt.options.devServer.port = addr.port;
    this._currentNuxt.options.devServer.url = getAddressURL(addr, !!this.listener.https);
    this._currentNuxt.options.devServer.https = this.options.devContext.proxy?.https;
    if (this.listener.https && !process$1.env.NODE_TLS_REJECT_UNAUTHORIZED) {
      console.warn("You might need `NODE_TLS_REJECT_UNAUTHORIZED=0` environment variable to make https work.");
    }
    await Promise.all([
      kit.writeTypes(this._currentNuxt).catch(console.error),
      kit.buildNuxt(this._currentNuxt)
    ]);
    if (!this._currentNuxt.server) {
      throw new Error("Nitro server has not been initialized.");
    }
    const distDir = resolve(this._currentNuxt.options.buildDir, "dist");
    await mkdir(distDir, { recursive: true });
    this._distWatcher = watch(distDir);
    this._distWatcher.on("change", () => {
      this.loadDebounced(true, ".nuxt/dist directory has been removed");
    });
    this._handler = toNodeListener(this._currentNuxt.server.app);
    this.emit("ready", "socketPath" in addr ? formatSocketURL(addr.socketPath, !!this.listener.https) : `http://127.0.0.1:${addr.port}`);
  }
  _watchConfig() {
    this._configWatcher = createConfigWatcher(
      this.cwd,
      this.options.dotenv.fileName,
      () => this.emit("restart"),
      (file) => this.loadDebounced(true, `${file} updated`)
    );
  }
}
function getAddressURL(addr, https) {
  const proto = https ? "https" : "http";
  let host = addr.address.includes(":") ? `[${addr.address}]` : addr.address;
  if (host === "[::]") {
    host = "localhost";
  }
  const port = addr.port || 3e3;
  return `${proto}://${host}:${port}/`;
}
function resolveDevServerOverrides(listenOptions) {
  if (listenOptions.public || p$1 === "codesandbox") {
    return {
      devServer: { cors: { origin: "*" } },
      vite: { server: { allowedHosts: true } }
    };
  }
  return {};
}
function resolveDevServerDefaults(listenOptions, urls = []) {
  const defaultConfig = {};
  if (urls) {
    defaultConfig.vite = {
      server: {
        allowedHosts: urls.filter((u) => !isSocketURL(u)).map((u) => new URL(u).hostname)
      }
    };
  }
  if (listenOptions.hostname) {
    const protocol = listenOptions.https ? "https" : "http";
    defaultConfig.devServer = { cors: { origin: [`${protocol}://${listenOptions.hostname}`, ...urls] } };
    defaultConfig.vite = defu(defaultConfig.vite, { server: { allowedHosts: [listenOptions.hostname] } });
  }
  return defaultConfig;
}
function createConfigWatcher(cwd, dotenvFileName = ".env", onRestart, onReload) {
  const configWatcher = watch(cwd);
  let configDirWatcher = existsSync(resolve(cwd, ".config")) ? createConfigDirWatcher(cwd, onReload) : void 0;
  const dotenvFileNames = new Set(Array.isArray(dotenvFileName) ? dotenvFileName : [dotenvFileName]);
  configWatcher.on("change", (_event, file) => {
    if (dotenvFileNames.has(file)) {
      onRestart();
    }
    if (RESTART_RE.test(file)) {
      onReload(file);
    }
    if (file === ".config") {
      configDirWatcher ||= createConfigDirWatcher(cwd, onReload);
    }
  });
  return () => {
    configWatcher.close();
    configDirWatcher?.();
  };
}
function createConfigDirWatcher(cwd, onReload) {
  const configDir = resolve(cwd, ".config");
  const configDirWatcher = watch(configDir);
  configDirWatcher.on("change", (_event, file) => {
    if (RESTART_RE.test(file)) {
      onReload(file);
    }
  });
  return () => configDirWatcher.close();
}
async function resolveLoadingTemplate(cwd) {
  const nuxtPath = resolveModulePath("nuxt", { from: cwd, try: true });
  const uiTemplatesPath = resolveModulePath("@nuxt/ui-templates", { from: nuxtPath || cwd });
  const r = await import(pathToFileURL(uiTemplatesPath).href);
  return r.loading || ((params) => `<h2>${params.loading}</h2>`);
}

const start = Date.now();
process$1.env.NODE_ENV = "development";
class IPC {
  enabled = !!process$1.send && !process$1.title?.includes("vitest") && process$1.env.__NUXT__FORK;
  constructor() {
    if (this.enabled) {
      process$1.once("unhandledRejection", (reason) => {
        this.send({ type: "nuxt:internal:dev:rejection", message: reason instanceof Error ? reason.toString() : "Unhandled Rejection" });
        process$1.exit();
      });
    }
    process$1.on("message", (message) => {
      if (message.type === "nuxt:internal:dev:context") {
        initialize(message.context, {}, message.socket ? void 0 : true);
      }
    });
    this.send({ type: "nuxt:internal:dev:fork-ready" });
  }
  send(message) {
    if (this.enabled) {
      process$1.send?.(message);
    }
  }
}
const ipc = new IPC();
async function initialize(devContext, ctx = {}, _listenOptions) {
  const devServerOverrides = resolveDevServerOverrides({
    public: devContext.public
  });
  const devServerDefaults = resolveDevServerDefaults({
    hostname: devContext.hostname,
    https: devContext.proxy?.https
  }, devContext.publicURLs);
  const devServer = new NuxtDevServer({
    cwd: devContext.cwd,
    overrides: defu(
      ctx.data?.overrides,
      { extends: devContext.args.extends },
      devServerOverrides
    ),
    defaults: devServerDefaults,
    logLevel: devContext.args.logLevel,
    clear: !!devContext.args.clear,
    dotenv: { cwd: devContext.cwd, fileName: devContext.args.dotenv },
    envName: devContext.args.envName,
    devContext: {
      proxy: devContext.proxy
    }
  });
  const listenOptions = _listenOptions === true || process$1.env._PORT ? { port: process$1.env._PORT ?? 0, hostname: "127.0.0.1", showURL: false } : _listenOptions;
  devServer.listener = listenOptions ? await listen(devServer.handler, listenOptions) : await createSocketListener(devServer.handler, devContext.proxy?.addr);
  if (process$1.env.DEBUG) {
    console.debug(`Using ${listenOptions ? "network" : "socket"} listener for Nuxt dev server.`);
  }
  devServer.listener._url = devServer.listener.url;
  if (devContext.proxy?.url) {
    devServer.listener.url = devContext.proxy.url;
  }
  if (devContext.proxy?.urls) {
    const _getURLs = devServer.listener.getURLs.bind(devServer.listener);
    devServer.listener.getURLs = async () => Array.from(/* @__PURE__ */ new Set([...devContext.proxy?.urls || [], ...await _getURLs()]));
  }
  let address;
  if (ipc.enabled) {
    devServer.on("loading:error", (_error) => {
      ipc.send({
        type: "nuxt:internal:dev:loading:error",
        error: {
          message: _error.message,
          stack: _error.stack,
          name: _error.name,
          code: "code" in _error ? _error.code : void 0
        }
      });
    });
    devServer.on("loading", (message) => {
      ipc.send({ type: "nuxt:internal:dev:loading", message });
    });
    devServer.on("restart", () => {
      ipc.send({ type: "nuxt:internal:dev:restart" });
    });
    devServer.on("ready", (payload) => {
      ipc.send({ type: "nuxt:internal:dev:ready", address: payload });
    });
  } else {
    devServer.on("ready", (payload) => {
      address = payload;
    });
  }
  await devServer.init();
  if (process$1.env.DEBUG) {
    console.debug(`Dev server (internal) initialized in ${Date.now() - start}ms`);
  }
  return {
    listener: devServer.listener,
    close: async () => {
      devServer.closeWatchers();
      await devServer.close();
    },
    onReady: (callback) => {
      if (address) {
        callback(address);
      } else {
        devServer.once("ready", (payload) => callback(payload));
      }
    },
    onRestart: (callback) => {
      let restarted = false;
      function restart() {
        if (!restarted) {
          restarted = true;
          callback(devServer);
        }
      }
      devServer.once("restart", restart);
      process$1.once("uncaughtException", restart);
      process$1.once("unhandledRejection", restart);
    }
  };
}

export { renderError as a, isSocketURL as b, initialize as i, parseSocketURL as p, resolveLoadingTemplate as r };
