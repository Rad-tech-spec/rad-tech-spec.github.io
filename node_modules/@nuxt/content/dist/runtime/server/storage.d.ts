import { type StorageValue, type Storage } from 'unstorage';
import type { H3Event } from 'h3';
import type { ParsedContent, ContentTransformer, ContentQueryBuilder, ContentQueryBuilderParams, ModuleOptions } from '@nuxt/content';
interface ParseContentOptions {
    csv?: ModuleOptions['csv'];
    yaml?: ModuleOptions['yaml'];
    highlight?: ModuleOptions['highlight'];
    markdown?: ModuleOptions['markdown'];
    transformers?: ContentTransformer[];
    pathMeta?: {
        locales?: ModuleOptions['locales'];
        defaultLocale?: ModuleOptions['defaultLocale'];
        respectPathCase?: ModuleOptions['respectPathCase'];
    };
    [key: string]: any;
}
export declare const sourceStorage: () => Storage<StorageValue>;
export declare const cacheStorage: () => Storage<StorageValue>;
export declare const cacheParsedStorage: () => Storage<StorageValue>;
export declare const getContentsIds: (event: H3Event, prefix?: string) => Promise<string[]>;
export declare function chunksFromArray<T>(arr: T[], n: number): Generator<T[], void>;
export declare const cleanCachedContents: () => void;
export declare const getContentsList: (event: H3Event, prefix?: string) => any;
export declare const getContent: (event: H3Event, id: string) => Promise<ParsedContent>;
/**
 * Parse content file using registered plugins
 */
export declare const parseContent: (id: string, content: StorageValue, opts?: ParseContentOptions) => Promise<any>;
export declare const createServerQueryFetch: <T = ParsedContent>(event: H3Event) => (query: ContentQueryBuilder<T>) => Promise<ContentQueryResponse<T_1>>;
/**
 * Query contents
 */
export declare function serverQueryContent<T = ParsedContent>(event: H3Event, params?: ContentQueryBuilderParams): ContentQueryBuilder<T>;
export declare function serverQueryContent<T = ParsedContent>(event: H3Event, query?: string, ...pathParts: string[]): ContentQueryBuilder<T>;
export {};
